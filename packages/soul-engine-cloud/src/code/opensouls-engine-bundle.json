{"imports":["zod","common-tags"],"exports":["ChatMessageRoleEnum","WorkingMemory","createCognitiveStep","forkStream","indentNicely","stripEntityAndVerb","stripEntityAndVerbFromStream","useActions","useBlueprintStore","useOrganizationStore","usePerceptions","useProcessManager","useProcessMemory","useRag","useSharedContext","useSoulMemory","useSoulStore","useTool","z"],"reexports":[],"__syncModuleProgram__":"({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () { 'use strict';   let z2,codeBlock;$h‍_imports([[\"zod\", [[\"z\", [$h‍_a => (z2 = $h‍_a),$h‍_live[\"z2\"]]]]],[\"common-tags\", [[\"codeBlock\", [$h‍_a => (codeBlock = $h‍_a)]]]]]);$h‍_live.forkStream();$h‍_live.createCognitiveStep();$h‍_live.indentNicely();$h‍_live.stripEntityAndVerb();$h‍_live.stripEntityAndVerbFromStream();$h‍_live.ChatMessageRoleEnum();$h‍_live.useActions();$h‍_live.useProcessManager();$h‍_live.usePerceptions();$h‍_live.useProcessMemory();$h‍_live.useSoulStore();$h‍_live.useBlueprintStore();$h‍_live.useOrganizationStore();$h‍_live.useSoulMemory();$h‍_live.useRag();$h‍_live.useTool();$h‍_live.useSharedContext();$h‍_live.WorkingMemory();   \n\n\n\n// ../../node_modules/web-streams-polyfill/dist/ponyfill.mjs\nvar e=  function() {\n };\nvar t=  function(e2) {\n  return typeof e2==  \"object\"&&  e2!==  null||  typeof e2==  \"function\";\n };\nvar o=  function(e2, t2) {\n  try {\n    Object.defineProperty(e2, \"name\", { value: t2, configurable: true});\n   }catch( e3) {\n   }\n };\nvar u=  function(e2) {\n  return new n(e2);\n };\nvar c=  function(e2) {\n  return u((t2)=>  t2(e2));\n };\nvar d=  function(e2) {\n  return l(e2);\n };\nvar f=  function(e2, t2, r) {\n  return i.call(e2, t2, r);\n };\nvar b=  function(e2, t2, o2) {\n  f(f(e2, t2, o2), undefined, r);\n };\nvar h=  function(e2, t2) {\n  b(e2, t2);\n };\nvar m=  function(e2, t2) {\n  b(e2, undefined, t2);\n };\nvar _=  function(e2, t2, r) {\n  return f(e2, t2, r);\n };\nvar p=  function(e2) {\n  f(e2, undefined, r);\n };\nvar S=  function(e2, t2, r) {\n  if( typeof e2!=  \"function\")\n    throw new TypeError(\"Argument is not a function\");\n  return Function.prototype.apply.call(e2, t2, r);\n };\nvar g=  function(e2, t2, r) {\n  try {\n    return c(S(e2, t2, r));\n   }catch( e3) {\n    return d(e3);\n   }\n };\nvar q=  function(e2, t2) {\n  e2._ownerReadableStream=  t2, t2._reader=  e2, t2._state===  \"readable\"?  B(e2):  t2._state===  \"closed\"?  function(e3) {\n    B(e3), A(e3);\n   }(e2): k(e2, t2._storedError);\n };\nvar E=  function(e2, t2) {\n  return Or(e2._ownerReadableStream, t2);\n };\nvar W=  function(e2) {\n  const t2=  e2._ownerReadableStream;\n  t2._state===  \"readable\"?  j(e2, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")):  function(e3, t3) {\n    k(e3, t3);\n   }(e2,new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), t2._readableStreamController[P](), t2._reader=  undefined, e2._ownerReadableStream=  undefined;\n };\nvar O=  function(e2) {\n  return new TypeError(\"Cannot \"+  e2+  \" a stream using a released reader\");\n };\nvar B=  function(e2) {\n  e2._closedPromise=  u((t2, r)=>  {\n    e2._closedPromise_resolve=  t2, e2._closedPromise_reject=  r;\n   });\n };\nvar k=  function(e2, t2) {\n  B(e2), j(e2, t2);\n };\nvar j=  function(e2, t2) {\n  e2._closedPromise_reject!==  undefined&&(  p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined);\n };\nvar A=  function(e2) {\n  e2._closedPromise_resolve!==  undefined&&(  e2._closedPromise_resolve(undefined), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined);\n };\nvar L=  function(e2, t2) {\n  if( e2!==  undefined&&   typeof( r=  e2)!=  \"object\"&&  typeof r!=  \"function\")\n    throw new TypeError( `${t2} is not an object.`);\n  var r;\n };\nvar F=  function(e2, t2) {\n  if( typeof e2!=  \"function\")\n    throw new TypeError( `${t2} is not a function.`);\n };\nvar I=  function(e2, t2) {\n  if( !function(e3) {\n    return typeof e3==  \"object\"&&  e3!==  null||  typeof e3==  \"function\";\n   }(e2))\n    throw new TypeError( `${t2} is not an object.`);\n };\nvar $=  function(e2, t2, r) {\n  if( e2===  undefined)\n    throw new TypeError( `Parameter ${t2} is required in '${r}'.`);\n };\nvar M=  function(e2, t2, r) {\n  if( e2===  undefined)\n    throw new TypeError( `${t2} is required in '${r}'.`);\n };\nvar Y=  function(e2) {\n  return Number(e2);\n };\nvar x=  function(e2) {\n  return e2===  0?  0:  e2;\n };\nvar Q=  function(e2, t2) {\n  const r=  Number.MAX_SAFE_INTEGER;\n  let o2=  Number(e2);\n  if( o2=  x(o2), !z(o2))\n    throw new TypeError( `${t2} is not a finite number`);\n  if( o2=  function(e3) {\n    return x(D(e3));\n   }(o2),o2<  0||  o2>  r)\n    throw new TypeError( `${t2} is outside the accepted range of 0 to ${r}, inclusive`);\n  return z(o2)&&  o2!==  0?  o2:  0;\n };\nvar N=  function(e2, t2) {\n  if( !Er(e2))\n    throw new TypeError( `${t2} is not a ReadableStream.`);\n };\nvar H=  function(e2) {\n  return new ReadableStreamDefaultReader(e2);\n };\nvar V=  function(e2, t2) {\n  e2._reader._readRequests.push(t2);\n };\nvar U=  function(e2, t2, r) {\n  const o2=  e2._reader._readRequests.shift();\n  r?  o2._closeSteps():  o2._chunkSteps(t2);\n };\nvar G=  function(e2) {\n  return e2._reader._readRequests.length;\n };\nvar X=  function(e2) {\n  const t2=  e2._reader;\n  return t2!==  undefined&&  !!J(t2);\n };\nvar J=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_readRequests\")&&  e2 instanceof ReadableStreamDefaultReader;\n };\nvar K=  function(e2, t2) {\n  const r=  e2._ownerReadableStream;\n  r._disturbed=  true, r._state===  \"closed\"?  t2._closeSteps():  r._state===  \"errored\"?  t2._errorSteps(r._storedError):  r._readableStreamController[C](t2);\n };\nvar Z=  function(e2, t2) {\n  const r=  e2._readRequests;\n  e2._readRequests=  new v(),r.forEach((e3)=> {\n    e3._errorSteps(t2);\n   });\n };\nvar ee=  function(e2) {\n  return new TypeError( `ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);\n };\nvar ne=  function(e2) {\n  return e2.slice();\n };\nvar ae=  function(e2, t2, r, o2, n) {\n  new Uint8Array(e2).set(new Uint8Array(r, o2, n), t2);\n };\nvar se=  function(e2, t2, r) {\n  if( e2.slice)\n    return e2.slice(t2, r);\n  const o2=  r-  t2, n=  new ArrayBuffer(o2);\n  return ae(n, 0, e2, t2, o2), n;\n };\nvar ue=  function(e2, t2) {\n  const r=  e2[t2];\n  if( r!=  null) {\n    if( typeof r!=  \"function\")\n      throw new TypeError( `${String(t2)} is not a function`);\n    return r;\n   }\n };\nvar ce=  function(e2) {\n  try {\n    const { done: t2, value: r}=   e2;\n    return f(s(r), (e3)=>(  { done: t2, value: e3}));\n   }catch( e3) {\n    return d(e3);\n   }\n };\nvar fe=  function(e2, r=  \"sync\", o2) {\n  if( o2===  undefined)\n    if( r===  \"async\") {\n      if( (o2=  ue(e2, de))===  undefined) {\n        return function(e3) {\n          const r2=  { next() {\n            let t2;\n            try {\n              t2=  be(e3);\n             }catch( e4) {\n              return d(e4);\n             }\n            return ce(t2);\n           },return(r3) {\n            let o3;\n            try {\n              const t2=  ue(e3.iterator, \"return\");\n              if( t2===  undefined)\n                return c({ done: true, value: r3});\n              o3=  S(t2, e3.iterator, [r3]);\n             }catch( e4) {\n              return d(e4);\n             }\n            return t(o3)?  ce(o3):  d(new TypeError(\"The iterator.return() method must return an object\"));\n           }};\n          return { iterator: r2, nextMethod: r2.next, done: false};\n         }(fe(e2,\"sync\", ue(e2, Symbol.iterator)));\n       }\n     }else\n      o2=  ue(e2, Symbol.iterator);\n  if( o2===  undefined)\n    throw new TypeError(\"The object is not iterable\");\n  const n=  S(o2, e2, []);\n  if( !t(n))\n    throw new TypeError(\"The iterator method must return an object\");\n  return { iterator: n, nextMethod: n.next, done: false};\n };\nvar be=  function(e2) {\n  const r=  S(e2.nextMethod, e2.iterator, []);\n  if( !t(r))\n    throw new TypeError(\"The iterator.next() method must return an object\");\n  return r;\n };\nvar _e=  function(e2) {\n  if( !t(e2))\n    return false;\n  if( !Object.prototype.hasOwnProperty.call(e2, \"_asyncIteratorImpl\"))\n    return false;\n  try {\n    return e2._asyncIteratorImpl instanceof he;\n   }catch( e3) {\n    return false;\n   }\n };\nvar pe=  function(e2) {\n  return new TypeError( `ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);\n };\nvar Se=  function(e2) {\n  const t2=  se(e2.buffer, e2.byteOffset, e2.byteOffset+  e2.byteLength);\n  return new Uint8Array(t2);\n };\nvar ge=  function(e2) {\n  const t2=  e2._queue.shift();\n  return e2._queueTotalSize-=  t2.size, e2._queueTotalSize<  0&&(  e2._queueTotalSize=  0), t2.value;\n };\nvar ve=  function(e2, t2, r) {\n  if( typeof( o2=  r)!=  \"number\"||  ye(o2)||  o2<  0||  r===  1/  0)\n    throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n  var o2;\n  e2._queue.push({ value: t2, size: r}),  e2._queueTotalSize+=  r;\n };\nvar we=  function(e2) {\n  e2._queue=  new v(),e2._queueTotalSize= 0;\n };\nvar Re=  function(e2) {\n  return e2===  DataView;\n };\nvar Te=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledReadableByteStream\")&&  e2 instanceof ReadableByteStreamController;\n };\nvar Ce=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_associatedReadableByteStreamController\")&&  e2 instanceof ReadableStreamBYOBRequest;\n };\nvar Pe=  function(e2) {\n  const t2=  function(e3) {\n    const t3=  e3._controlledReadableByteStream;\n    if( t3._state!==  \"readable\")\n      return false;\n    if( e3._closeRequested)\n      return false;\n    if( !e3._started)\n      return false;\n    if( X(t3)&&  G(t3)>  0)\n      return true;\n    if( ot(t3)&&  rt(t3)>  0)\n      return true;\n    const r=  Ve(e3);\n    if( r>  0)\n      return true;\n    return false;\n   }(e2);\n  if( !t2)\n    return;\n  if( e2._pulling)\n    return void( e2._pullAgain=  true);\n  e2._pulling=  true;\n  b(e2._pullAlgorithm(), ()=>(  e2._pulling=  false, e2._pullAgain&&(  e2._pullAgain=  false, Pe(e2)), null), (t3)=>(  Qe(e2, t3), null));\n };\nvar qe=  function(e2) {\n  De(e2), e2._pendingPullIntos=  new v();\n };\nvar Ee=  function(e2, t2) {\n  let r=  false;\n  e2._state===  \"closed\"&&(  r=  true);\n  const o2=  We(t2);\n  t2.readerType===  \"default\"?  U(e2, o2, r):  function(e3, t3, r2) {\n    const o3=  e3._reader, n=  o3._readIntoRequests.shift();\n    r2?  n._closeSteps(t3):  n._chunkSteps(t3);\n   }(e2,o2, r);\n };\nvar We=  function(e2) {\n  const { bytesFilled: t2, elementSize: r}=   e2;\n  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2/  r);\n };\nvar Oe=  function(e2, t2, r, o2) {\n  e2._queue.push({ buffer: t2, byteOffset: r, byteLength: o2}),  e2._queueTotalSize+=  o2;\n };\nvar Be=  function(e2, t2, r, o2) {\n  let n;\n  try {\n    n=  se(t2, r, r+  o2);\n   }catch( t3) {\n    throw Qe(e2, t3), t3;\n   }\n  Oe(e2, n, 0, o2);\n };\nvar ke=  function(e2, t2) {\n  t2.bytesFilled>  0&&  Be(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), $e(e2);\n };\nvar je=  function(e2, t2) {\n  const r=  Math.min(e2._queueTotalSize, t2.byteLength-  t2.bytesFilled), o2=  t2.bytesFilled+  r;\n  let n=  r, a=  false;\n  const i=  o2-  o2%  t2.elementSize;\n  i>=  t2.minimumFill&&(  n=  i-  t2.bytesFilled, a=  true);\n  const l=  e2._queue;\n  for(; n>  0;)  {\n    const r2=  l.peek(), o3=  Math.min(n, r2.byteLength), a2=  t2.byteOffset+  t2.bytesFilled;\n    ae(t2.buffer, a2, r2.buffer, r2.byteOffset, o3), r2.byteLength===  o3?  l.shift():(  r2.byteOffset+=  o3, r2.byteLength-=  o3), e2._queueTotalSize-=  o3, Ae(e2, o3, t2), n-=  o3;\n   }\n  return a;\n };\nvar Ae=  function(e2, t2, r) {\n  r.bytesFilled+=  t2;\n };\nvar ze=  function(e2) {\n  e2._queueTotalSize===  0&&  e2._closeRequested?(  Me(e2), Br(e2._controlledReadableByteStream)):  Pe(e2);\n };\nvar De=  function(e2) {\n  e2._byobRequest!==  null&&(  e2._byobRequest._associatedReadableByteStreamController=  undefined, e2._byobRequest._view=  null, e2._byobRequest=  null);\n };\nvar Le=  function(e2) {\n  for(; e2._pendingPullIntos.length>  0;)  {\n    if( e2._queueTotalSize===  0)\n      return;\n    const t2=  e2._pendingPullIntos.peek();\n    je(e2, t2)&&(  $e(e2), Ee(e2._controlledReadableByteStream, t2));\n   }\n };\nvar Fe=  function(e2, t2, r, o2) {\n  const n=  e2._controlledReadableByteStream, a=  t2.constructor, i=  function(e3) {\n    return Re(e3)?  1:  e3.BYTES_PER_ELEMENT;\n   }(a),{ byteOffset: l, byteLength: s}=   t2, u2=  r*  i;\n  let c2;\n  try {\n    c2=  ie(t2.buffer);\n   }catch( e3) {\n    return void o2._errorSteps(e3);\n   }\n  const d2=  { buffer: c2, bufferByteLength: c2.byteLength, byteOffset: l, byteLength: s, bytesFilled: 0, minimumFill: u2, elementSize: i, viewConstructor: a, readerType: \"byob\"};\n  if( e2._pendingPullIntos.length>  0)\n    return e2._pendingPullIntos.push(d2), void tt(n, o2);\n  if( n._state!==  \"closed\") {\n    if( e2._queueTotalSize>  0) {\n      if( je(e2, d2)) {\n        const t3=  We(d2);\n        return ze(e2), void o2._chunkSteps(t3);\n       }\n      if( e2._closeRequested) {\n        const t3=  new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n        return Qe(e2, t3), void o2._errorSteps(t3);\n       }\n     }\n    e2._pendingPullIntos.push(d2), tt(n, o2), Pe(e2);\n   }else {\n    const e3=  new a(d2.buffer, d2.byteOffset, 0);\n    o2._closeSteps(e3);\n   }\n };\nvar Ie=  function(e2, t2) {\n  const r=  e2._pendingPullIntos.peek();\n  De(e2);\n  e2._controlledReadableByteStream._state===  \"closed\"?  function(e3, t3) {\n    t3.readerType===  \"none\"&&  $e(e3);\n    const r2=  e3._controlledReadableByteStream;\n    if( ot(r2))\n      for(; rt(r2)>  0;)\n        Ee(r2, $e(e3));\n   }(e2,r):  function(e3, t3, r2) {\n    if( Ae(0, t3, r2), r2.readerType===  \"none\")\n      return ke(e3, r2), void Le(e3);\n    if( r2.bytesFilled<  r2.minimumFill)\n      return;\n    $e(e3);\n    const o2=  r2.bytesFilled%  r2.elementSize;\n    if( o2>  0) {\n      const t4=  r2.byteOffset+  r2.bytesFilled;\n      Be(e3, r2.buffer, t4-  o2, o2);\n     }\n    r2.bytesFilled-=  o2, Ee(e3._controlledReadableByteStream, r2), Le(e3);\n   }(e2,t2, r), Pe(e2);\n };\nvar $e=  function(e2) {\n  return e2._pendingPullIntos.shift();\n };\nvar Me=  function(e2) {\n  e2._pullAlgorithm=  undefined, e2._cancelAlgorithm=  undefined;\n };\nvar Ye=  function(e2) {\n  const t2=  e2._controlledReadableByteStream;\n  if( !e2._closeRequested&&  t2._state===  \"readable\")\n    if( e2._queueTotalSize>  0)\n      e2._closeRequested=  true;else\n         {\n      if( e2._pendingPullIntos.length>  0) {\n        const t3=  e2._pendingPullIntos.peek();\n        if( t3.bytesFilled%  t3.elementSize!=  0) {\n          const t4=  new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n          throw Qe(e2, t4), t4;\n         }\n       }\n      Me(e2), Br(t2);\n     }\n };\nvar xe=  function(e2, t2) {\n  const r=  e2._controlledReadableByteStream;\n  if( e2._closeRequested||  r._state!==  \"readable\")\n    return;\n  const { buffer: o2, byteOffset: n, byteLength: a}=   t2;\n  if( le(o2))\n    throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n  const i=  ie(o2);\n  if( e2._pendingPullIntos.length>  0) {\n    const t3=  e2._pendingPullIntos.peek();\n    if( le(t3.buffer))\n      throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk\");\n    De(e2), t3.buffer=  ie(t3.buffer), t3.readerType===  \"none\"&&  ke(e2, t3);\n   }\n  if( X(r)){\n    if( function(e3) {\n      const t3=  e3._controlledReadableByteStream._reader;\n      for(; t3._readRequests.length>  0;)  {\n        if( e3._queueTotalSize===  0)\n          return;\n        Ne(e3, t3._readRequests.shift());\n       }\n     }(e2),G(r)===  0)\n      Oe(e2, i, n, a);else\n         {\n      e2._pendingPullIntos.length>  0&&  $e(e2);\n      U(r, new Uint8Array(i, n, a), false);\n     }}else\n\n    ot(r)?(  Oe(e2, i, n, a), Le(e2)):  Oe(e2, i, n, a);\n  Pe(e2);\n };\nvar Qe=  function(e2, t2) {\n  const r=  e2._controlledReadableByteStream;\n  r._state===  \"readable\"&&(  qe(e2), we(e2), Me(e2), kr(r, t2));\n };\nvar Ne=  function(e2, t2) {\n  const r=  e2._queue.shift();\n  e2._queueTotalSize-=  r.byteLength, ze(e2);\n  const o2=  new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n  t2._chunkSteps(o2);\n };\nvar He=  function(e2) {\n  if( e2._byobRequest===  null&&  e2._pendingPullIntos.length>  0) {\n    const t2=  e2._pendingPullIntos.peek(), r=  new Uint8Array(t2.buffer, t2.byteOffset+  t2.bytesFilled, t2.byteLength-  t2.bytesFilled), o2=  Object.create(ReadableStreamBYOBRequest.prototype);\n    (function(e3, t3, r2) {\n      e3._associatedReadableByteStreamController=  t3, e3._view=  r2;\n     })(o2,e2, r), e2._byobRequest=  o2;\n   }\n  return e2._byobRequest;\n };\nvar Ve=  function(e2) {\n  const t2=  e2._controlledReadableByteStream._state;\n  return t2===  \"errored\"?  null:  t2===  \"closed\"?  0:  e2._strategyHWM-  e2._queueTotalSize;\n };\nvar Ue=  function(e2, t2) {\n  const r=  e2._pendingPullIntos.peek();\n  if( e2._controlledReadableByteStream._state===  \"closed\") {\n    if( t2!==  0)\n      throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n   }else {\n    if( t2===  0)\n      throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n    if( r.bytesFilled+  t2>  r.byteLength)\n      throw new RangeError(\"bytesWritten out of range\");\n   }\n  r.buffer=  ie(r.buffer), Ie(e2, t2);\n };\nvar Ge=  function(e2, t2) {\n  const r=  e2._pendingPullIntos.peek();\n  if( e2._controlledReadableByteStream._state===  \"closed\") {\n    if( t2.byteLength!==  0)\n      throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n   }else if( t2.byteLength===  0)\n    throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n  if( r.byteOffset+  r.bytesFilled!==  t2.byteOffset)\n    throw new RangeError(\"The region specified by view does not match byobRequest\");\n  if( r.bufferByteLength!==  t2.buffer.byteLength)\n    throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n  if( r.bytesFilled+  t2.byteLength>  r.byteLength)\n    throw new RangeError(\"The region specified by view is larger than byobRequest\");\n  const o2=  t2.byteLength;\n  r.buffer=  ie(t2.buffer), Ie(e2, o2);\n };\nvar Xe=  function(e2, t2, r, o2, n, a, i) {\n  t2._controlledReadableByteStream=  e2, t2._pullAgain=  false, t2._pulling=  false, t2._byobRequest=  null, t2._queue=  t2._queueTotalSize=  undefined, we(t2), t2._closeRequested=  false, t2._started=  false, t2._strategyHWM=  a, t2._pullAlgorithm=  o2, t2._cancelAlgorithm=  n, t2._autoAllocateChunkSize=  i, t2._pendingPullIntos=  new v(),e2._readableStreamController= t2;\n  b(c(r()), ()=>(  t2._started=  true, Pe(t2), null), (e3)=>(  Qe(t2, e3), null));\n };\nvar Je=  function(e2) {\n  return new TypeError( `ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);\n };\nvar Ke=  function(e2) {\n  return new TypeError( `ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);\n };\nvar Ze=  function(e2, t2) {\n  if( (e2=   `${e2}`)!== \"byob\")\n    throw new TypeError( `${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  return e2;\n };\nvar et=  function(e2) {\n  return new ReadableStreamBYOBReader(e2);\n };\nvar tt=  function(e2, t2) {\n  e2._reader._readIntoRequests.push(t2);\n };\nvar rt=  function(e2) {\n  return e2._reader._readIntoRequests.length;\n };\nvar ot=  function(e2) {\n  const t2=  e2._reader;\n  return t2!==  undefined&&  !!nt(t2);\n };\nvar nt=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_readIntoRequests\")&&  e2 instanceof ReadableStreamBYOBReader;\n };\nvar at=  function(e2, t2, r, o2) {\n  const n=  e2._ownerReadableStream;\n  n._disturbed=  true, n._state===  \"errored\"?  o2._errorSteps(n._storedError):  Fe(n._readableStreamController, t2, r, o2);\n };\nvar it=  function(e2, t2) {\n  const r=  e2._readIntoRequests;\n  e2._readIntoRequests=  new v(),r.forEach((e3)=> {\n    e3._errorSteps(t2);\n   });\n };\nvar lt=  function(e2) {\n  return new TypeError( `ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);\n };\nvar st=  function(e2, t2) {\n  const { highWaterMark: r}=   e2;\n  if( r===  undefined)\n    return t2;\n  if( ye(r)||  r<  0)\n    throw new RangeError(\"Invalid highWaterMark\");\n  return r;\n };\nvar ut=  function(e2) {\n  const { size: t2}=   e2;\n  return t2||(  ()=>  1);\n };\nvar ct=  function(e2, t2) {\n  L(e2, t2);\n  const r=  e2==  null?  undefined:  e2.highWaterMark, o2=  e2==  null?  undefined:  e2.size;\n  return { highWaterMark: r===  undefined?  undefined:  Y(r), size: o2===  undefined?  undefined:  dt(o2,  `${t2} has member 'size' that`)};\n };\nvar dt=  function(e2, t2) {\n  return F(e2, t2), (t3)=>  Y(e2(t3));\n };\nvar ft=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  g(e2, t2, [r2]);\n };\nvar bt=  function(e2, t2, r) {\n  return F(e2, r), ()=>  g(e2, t2, []);\n };\nvar ht=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  S(e2, t2, [r2]);\n };\nvar mt=  function(e2, t2, r) {\n  return F(e2, r), (r2, o2)=>  g(e2, t2, [r2, o2]);\n };\nvar _t=  function(e2, t2) {\n  if( !gt(e2))\n    throw new TypeError( `${t2} is not a WritableStream.`);\n };\nvar yt=  function(e2) {\n  return new WritableStreamDefaultWriter(e2);\n };\nvar St=  function(e2) {\n  e2._state=  \"writable\", e2._storedError=  undefined, e2._writer=  undefined, e2._writableStreamController=  undefined, e2._writeRequests=  new v(),e2._inFlightWriteRequest= undefined, e2._closeRequest=  undefined, e2._inFlightCloseRequest=  undefined, e2._pendingAbortRequest=  undefined, e2._backpressure=  false;\n };\nvar gt=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_writableStreamController\")&&  e2 instanceof WritableStream;\n };\nvar vt=  function(e2) {\n  return e2._writer!==  undefined;\n };\nvar wt=  function(e2, t2) {\n  var r;\n  if( e2._state===  \"closed\"||  e2._state===  \"errored\")\n    return c(undefined);\n  e2._writableStreamController._abortReason=  t2, (r=  e2._writableStreamController._abortController)===  null||  r===  undefined||  r.abort(t2);\n  const o2=  e2._state;\n  if( o2===  \"closed\"||  o2===  \"errored\")\n    return c(undefined);\n  if( e2._pendingAbortRequest!==  undefined)\n    return e2._pendingAbortRequest._promise;\n  let n=  false;\n  o2===  \"erroring\"&&(  n=  true, t2=  undefined);\n  const a=  u((r2, o3)=>  {\n    e2._pendingAbortRequest=  { _promise: undefined, _resolve: r2, _reject: o3, _reason: t2, _wasAlreadyErroring: n};\n   });\n  return e2._pendingAbortRequest._promise=  a, n||  Ct(e2, t2), a;\n };\nvar Rt=  function(e2) {\n  const t2=  e2._state;\n  if( t2===  \"closed\"||  t2===  \"errored\")\n    return d(new TypeError( `The stream (in ${t2} state) is not in the writable state and cannot be closed`));\n  const r=  u((t3, r2)=>  {\n    const o3=  { _resolve: t3, _reject: r2};\n    e2._closeRequest=  o3;\n   }),o2=  e2._writer;\n  var n;\n  return o2!==  undefined&&  e2._backpressure&&  t2===  \"writable\"&&  or(o2), ve(n=  e2._writableStreamController, Dt, 0), Mt(n), r;\n };\nvar Tt=  function(e2, t2) {\n  e2._state!==  \"writable\"?  Pt(e2):  Ct(e2, t2);\n };\nvar Ct=  function(e2, t2) {\n  const r=  e2._writableStreamController;\n  e2._state=  \"erroring\", e2._storedError=  t2;\n  const o2=  e2._writer;\n  o2!==  undefined&&  jt(o2, t2), !function(e3) {\n    if( e3._inFlightWriteRequest===  undefined&&  e3._inFlightCloseRequest===  undefined)\n      return false;\n    return true;\n   }(e2)&& r._started&&  Pt(e2);\n };\nvar Pt=  function(e2) {\n  e2._state=  \"errored\", e2._writableStreamController[R]();\n  const t2=  e2._storedError;\n  if( e2._writeRequests.forEach((e3)=>  {\n    e3._reject(t2);\n   }),e2._writeRequests=  new v(),e2._pendingAbortRequest=== undefined)\n    return void Et(e2);\n  const r=  e2._pendingAbortRequest;\n  if( e2._pendingAbortRequest=  undefined, r._wasAlreadyErroring)\n    return r._reject(t2), void Et(e2);\n  b(e2._writableStreamController[w](r._reason), ()=>(  r._resolve(), Et(e2), null), (t3)=>(  r._reject(t3), Et(e2), null));\n };\nvar qt=  function(e2) {\n  return e2._closeRequest!==  undefined||  e2._inFlightCloseRequest!==  undefined;\n };\nvar Et=  function(e2) {\n  e2._closeRequest!==  undefined&&(  e2._closeRequest._reject(e2._storedError), e2._closeRequest=  undefined);\n  const t2=  e2._writer;\n  t2!==  undefined&&  Jt(t2, e2._storedError);\n };\nvar Wt=  function(e2, t2) {\n  const r=  e2._writer;\n  r!==  undefined&&  t2!==  e2._backpressure&&(  t2?  function(e3) {\n    Zt(e3);\n   }(r): or(r)), e2._backpressure=  t2;\n };\nvar Ot=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_ownerWritableStream\")&&  e2 instanceof WritableStreamDefaultWriter;\n };\nvar Bt=  function(e2) {\n  return Rt(e2._ownerWritableStream);\n };\nvar kt=  function(e2, t2) {\n  e2._closedPromiseState===  \"pending\"?  Jt(e2, t2):  function(e3, t3) {\n    Xt(e3, t3);\n   }(e2,t2);\n };\nvar jt=  function(e2, t2) {\n  e2._readyPromiseState===  \"pending\"?  rr(e2, t2):  function(e3, t3) {\n    er(e3, t3);\n   }(e2,t2);\n };\nvar At=  function(e2) {\n  const t2=  e2._ownerWritableStream, r=  new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n  jt(e2, r), kt(e2, r), t2._writer=  undefined, e2._ownerWritableStream=  undefined;\n };\nvar zt=  function(e2, t2) {\n  const r=  e2._ownerWritableStream, o2=  r._writableStreamController, n=  function(e3, t3) {\n    try {\n      return e3._strategySizeAlgorithm(t3);\n     }catch( t4) {\n      return Yt(e3, t4), 1;\n     }\n   }(o2,t2);\n  if( r!==  e2._ownerWritableStream)\n    return d(Ut(\"write to\"));\n  const a=  r._state;\n  if( a===  \"errored\")\n    return d(r._storedError);\n  if( qt(r)||  a===  \"closed\")\n    return d(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n  if( a===  \"erroring\")\n    return d(r._storedError);\n  const i=  function(e3) {\n    return u((t3, r2)=>  {\n      const o3=  { _resolve: t3, _reject: r2};\n      e3._writeRequests.push(o3);\n     });\n   }(r);\n  return function(e3, t3, r2) {\n    try {\n      ve(e3, t3, r2);\n     }catch( t4) {\n      return void Yt(e3, t4);\n     }\n    const o3=  e3._controlledWritableStream;\n    if( !qt(o3)&&  o3._state===  \"writable\") {\n      Wt(o3, xt(e3));\n     }\n    Mt(e3);\n   }(o2,t2, n), i;\n };\nvar Lt=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledWritableStream\")&&  e2 instanceof WritableStreamDefaultController;\n };\nvar Ft=  function(e2, t2, r, o2, n, a, i, l) {\n  t2._controlledWritableStream=  e2, e2._writableStreamController=  t2, t2._queue=  undefined, t2._queueTotalSize=  undefined, we(t2), t2._abortReason=  undefined, t2._abortController=  function() {\n    if( pt)\n      return new AbortController();\n   }(),t2._started=  false, t2._strategySizeAlgorithm=  l, t2._strategyHWM=  i, t2._writeAlgorithm=  o2, t2._closeAlgorithm=  n, t2._abortAlgorithm=  a;\n  const s=  xt(t2);\n  Wt(e2, s);\n  b(c(r()), ()=>(  t2._started=  true, Mt(t2), null), (r2)=>(  t2._started=  true, Tt(e2, r2), null));\n };\nvar It=  function(e2) {\n  e2._writeAlgorithm=  undefined, e2._closeAlgorithm=  undefined, e2._abortAlgorithm=  undefined, e2._strategySizeAlgorithm=  undefined;\n };\nvar $t=  function(e2) {\n  return e2._strategyHWM-  e2._queueTotalSize;\n };\nvar Mt=  function(e2) {\n  const t2=  e2._controlledWritableStream;\n  if( !e2._started)\n    return;\n  if( t2._inFlightWriteRequest!==  undefined)\n    return;\n  if( t2._state===  \"erroring\")\n    return void Pt(t2);\n  if( e2._queue.length===  0)\n    return;\n  const r=  e2._queue.peek().value;\n  r===  Dt?  function(e3) {\n    const t3=  e3._controlledWritableStream;\n    (function(e4) {\n      e4._inFlightCloseRequest=  e4._closeRequest, e4._closeRequest=  undefined;\n     })(t3),ge(e3);\n    const r2=  e3._closeAlgorithm();\n    It(e3), b(r2, ()=>(  function(e4) {\n      e4._inFlightCloseRequest._resolve(undefined), e4._inFlightCloseRequest=  undefined, e4._state===  \"erroring\"&&(  e4._storedError=  undefined, e4._pendingAbortRequest!==  undefined&&(  e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest=  undefined)), e4._state=  \"closed\";\n      const t4=  e4._writer;\n      t4!==  undefined&&  Kt(t4);\n     }(t3),null), (e4)=>(  function(e5, t4) {\n      e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest=  undefined, e5._pendingAbortRequest!==  undefined&&(  e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest=  undefined), Tt(e5, t4);\n     }(t3,e4), null));\n   }(e2): function(e3, t3) {\n    const r2=  e3._controlledWritableStream;\n    (function(e4) {\n      e4._inFlightWriteRequest=  e4._writeRequests.shift();\n     })(r2);\n    const o2=  e3._writeAlgorithm(t3);\n    b(o2, ()=>  {\n      (function(e4) {\n        e4._inFlightWriteRequest._resolve(undefined), e4._inFlightWriteRequest=  undefined;\n       })(r2);\n      const t4=  r2._state;\n      if( ge(e3), !qt(r2)&&  t4===  \"writable\") {\n        const t5=  xt(e3);\n        Wt(r2, t5);\n       }\n      return Mt(e3), null;\n     },(t4)=>(  r2._state===  \"writable\"&&  It(e3), function(e4, t5) {\n      e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest=  undefined, Tt(e4, t5);\n     }(r2,t4), null));\n   }(e2,r);\n };\nvar Yt=  function(e2, t2) {\n  e2._controlledWritableStream._state===  \"writable\"&&  Qt(e2, t2);\n };\nvar xt=  function(e2) {\n  return $t(e2)<=  0;\n };\nvar Qt=  function(e2, t2) {\n  const r=  e2._controlledWritableStream;\n  It(e2), Ct(r, t2);\n };\nvar Nt=  function(e2) {\n  return new TypeError( `WritableStream.prototype.${e2} can only be used on a WritableStream`);\n };\nvar Ht=  function(e2) {\n  return new TypeError( `WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);\n };\nvar Vt=  function(e2) {\n  return new TypeError( `WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);\n };\nvar Ut=  function(e2) {\n  return new TypeError(\"Cannot \"+  e2+  \" a stream using a released writer\");\n };\nvar Gt=  function(e2) {\n  e2._closedPromise=  u((t2, r)=>  {\n    e2._closedPromise_resolve=  t2, e2._closedPromise_reject=  r, e2._closedPromiseState=  \"pending\";\n   });\n };\nvar Xt=  function(e2, t2) {\n  Gt(e2), Jt(e2, t2);\n };\nvar Jt=  function(e2, t2) {\n  e2._closedPromise_reject!==  undefined&&(  p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined, e2._closedPromiseState=  \"rejected\");\n };\nvar Kt=  function(e2) {\n  e2._closedPromise_resolve!==  undefined&&(  e2._closedPromise_resolve(undefined), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined, e2._closedPromiseState=  \"resolved\");\n };\nvar Zt=  function(e2) {\n  e2._readyPromise=  u((t2, r)=>  {\n    e2._readyPromise_resolve=  t2, e2._readyPromise_reject=  r;\n   }),e2._readyPromiseState=  \"pending\";\n };\nvar er=  function(e2, t2) {\n  Zt(e2), rr(e2, t2);\n };\nvar tr=  function(e2) {\n  Zt(e2), or(e2);\n };\nvar rr=  function(e2, t2) {\n  e2._readyPromise_reject!==  undefined&&(  p(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve=  undefined, e2._readyPromise_reject=  undefined, e2._readyPromiseState=  \"rejected\");\n };\nvar or=  function(e2) {\n  e2._readyPromise_resolve!==  undefined&&(  e2._readyPromise_resolve(undefined), e2._readyPromise_resolve=  undefined, e2._readyPromise_reject=  undefined, e2._readyPromiseState=  \"fulfilled\");\n };\nvar ir=  function(t2, r, o2, n, a, i) {\n  const l=  H(t2), s=  yt(r);\n  t2._disturbed=  true;\n  let _2=  false, y=  c(undefined);\n  return u((S2, g2)=>  {\n    let v;\n    if( i!==  undefined) {\n      if( v=  ()=>  {\n        const e2=  i.reason!==  undefined?  i.reason:  new ar(\"Aborted\", \"AbortError\"), o3=  [];\n        n||  o3.push(()=>  r._state===  \"writable\"?  wt(r, e2):  c(undefined)), a||  o3.push(()=>  t2._state===  \"readable\"?  Or(t2, e2):  c(undefined)), q2(()=>  Promise.all(o3.map((e3)=>  e3())), true, e2);\n       },i.aborted)\n        return void v();\n      i.addEventListener(\"abort\", v);\n     }\n    var w, R, T;\n    if( P(t2, l._closedPromise, (e2)=>(  n?  E2(true, e2):  q2(()=>  wt(r, e2), true, e2), null)), P(r, s._closedPromise, (e2)=>(  a?  E2(true, e2):  q2(()=>  Or(t2, e2), true, e2), null)), w=  t2, R=  l._closedPromise, T=  ()=>(  o2?  E2():  q2(()=>  function(e2) {\n      const t3=  e2._ownerWritableStream, r2=  t3._state;\n      return qt(t3)||  r2===  \"closed\"?  c(undefined):  r2===  \"errored\"?  d(t3._storedError):  Bt(e2);\n     }(s)),null), w._state===  \"closed\"?  T():  h(R, T), qt(r)||  r._state===  \"closed\") {\n      const e2=  new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n      a?  E2(true, e2):  q2(()=>  Or(t2, e2), true, e2);\n     }\n    function C() {\n      const e2=  y;\n      return f(y, ()=>  e2!==  y?  C():  undefined);\n     }\n    function P(e2, t3, r2) {\n      e2._state===  \"errored\"?  r2(e2._storedError):  m(t3, r2);\n     }\n    function q2(e2, t3, o3) {\n      function n2() {\n        return b(e2(), ()=>  O2(t3, o3), (e3)=>  O2(true, e3)), null;\n       }\n      _2||(  _2=  true, r._state!==  \"writable\"||  qt(r)?  n2():  h(C(), n2));\n     }\n    function E2(e2, t3) {\n      _2||(  _2=  true, r._state!==  \"writable\"||  qt(r)?  O2(e2, t3):  h(C(), ()=>  O2(e2, t3)));\n     }\n    function O2(e2, t3) {\n      return At(s), W(l), i!==  undefined&&  i.removeEventListener(\"abort\", v), e2?  g2(t3):  S2(undefined), null;\n     }\n    p(u((t3, r2)=>  {\n      (function o(n2) {\n        n2?  t3():  f(_2?  c(true):  f(s._readyPromise, ()=>  u((t4, r3)=>  {\n          K(l, { _chunkSteps: (r4)=>  {\n            y=  f(zt(s, r4), undefined, e), t4(false);\n           },_closeSteps: ()=>  t4(true), _errorSteps: r3});\n         })),o, r2);\n       })(false);\n     }));\n   });\n };\nvar lr=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledReadableStream\")&&  e2 instanceof ReadableStreamDefaultController;\n };\nvar sr=  function(e2) {\n  if( !ur(e2))\n    return;\n  if( e2._pulling)\n    return void( e2._pullAgain=  true);\n  e2._pulling=  true;\n  b(e2._pullAlgorithm(), ()=>(  e2._pulling=  false, e2._pullAgain&&(  e2._pullAgain=  false, sr(e2)), null), (t2)=>(  br(e2, t2), null));\n };\nvar ur=  function(e2) {\n  const t2=  e2._controlledReadableStream;\n  if( !mr(e2))\n    return false;\n  if( !e2._started)\n    return false;\n  if( Wr(t2)&&  G(t2)>  0)\n    return true;\n  return hr(e2)>  0;\n };\nvar cr=  function(e2) {\n  e2._pullAlgorithm=  undefined, e2._cancelAlgorithm=  undefined, e2._strategySizeAlgorithm=  undefined;\n };\nvar dr=  function(e2) {\n  if( !mr(e2))\n    return;\n  const t2=  e2._controlledReadableStream;\n  e2._closeRequested=  true, e2._queue.length===  0&&(  cr(e2), Br(t2));\n };\nvar fr=  function(e2, t2) {\n  if( !mr(e2))\n    return;\n  const r=  e2._controlledReadableStream;\n  if( Wr(r)&&  G(r)>  0)\n    U(r, t2, false);else\n       {\n    let r2;\n    try {\n      r2=  e2._strategySizeAlgorithm(t2);\n     }catch( t3) {\n      throw br(e2, t3), t3;\n     }\n    try {\n      ve(e2, t2, r2);\n     }catch( t3) {\n      throw br(e2, t3), t3;\n     }\n   }\n  sr(e2);\n };\nvar br=  function(e2, t2) {\n  const r=  e2._controlledReadableStream;\n  r._state===  \"readable\"&&(  we(e2), cr(e2), kr(r, t2));\n };\nvar hr=  function(e2) {\n  const t2=  e2._controlledReadableStream._state;\n  return t2===  \"errored\"?  null:  t2===  \"closed\"?  0:  e2._strategyHWM-  e2._queueTotalSize;\n };\nvar mr=  function(e2) {\n  const t2=  e2._controlledReadableStream._state;\n  return !e2._closeRequested&&  t2===  \"readable\";\n };\nvar _r=  function(e2, t2, r, o2, n, a, i) {\n  t2._controlledReadableStream=  e2, t2._queue=  undefined, t2._queueTotalSize=  undefined, we(t2), t2._started=  false, t2._closeRequested=  false, t2._pullAgain=  false, t2._pulling=  false, t2._strategySizeAlgorithm=  i, t2._strategyHWM=  a, t2._pullAlgorithm=  o2, t2._cancelAlgorithm=  n, e2._readableStreamController=  t2;\n  b(c(r()), ()=>(  t2._started=  true, sr(t2), null), (e3)=>(  br(t2, e3), null));\n };\nvar pr=  function(e2) {\n  return new TypeError( `ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);\n };\nvar yr=  function(e2, t2) {\n  return Te(e2._readableStreamController)?  function(e3) {\n    let t3, r, o2, n, a, i=  H(e3), l=  false, s=  false, d2=  false, f2=  false, b2=  false;\n    const h2=  u((e4)=>  {\n      a=  e4;\n     });\n    function _2(e4) {\n      m(e4._closedPromise, (t4)=>(  e4!==  i||(  Qe(o2._readableStreamController, t4), Qe(n._readableStreamController, t4), f2&&  b2||  a(undefined)), null));\n     }\n    function p2() {\n      nt(i)&&(  W(i), i=  H(e3), _2(i));\n      K(i, { _chunkSteps: (t4)=>  {\n        y(()=>  {\n          s=  false, d2=  false;\n          const r2=  t4;\n          let i2=  t4;\n          if( !f2&&  !b2)\n            try {\n              i2=  Se(t4);\n             }catch( t5) {\n              return Qe(o2._readableStreamController, t5), Qe(n._readableStreamController, t5), void a(Or(e3, t5));\n             }\n          f2||  xe(o2._readableStreamController, r2), b2||  xe(n._readableStreamController, i2), l=  false, s?  g2():  d2&&  v();\n         });\n       },_closeSteps: ()=>  {\n        l=  false, f2||  Ye(o2._readableStreamController), b2||  Ye(n._readableStreamController), o2._readableStreamController._pendingPullIntos.length>  0&&  Ue(o2._readableStreamController, 0), n._readableStreamController._pendingPullIntos.length>  0&&  Ue(n._readableStreamController, 0), f2&&  b2||  a(undefined);\n       },_errorSteps: ()=>  {\n        l=  false;\n       }});\n     }\n    function S2(t4, r2) {\n      J(i)&&(  W(i), i=  et(e3), _2(i));\n      const u2=  r2?  n:  o2, c2=  r2?  o2:  n;\n      at(i, t4, 1, { _chunkSteps: (t5)=>  {\n        y(()=>  {\n          s=  false, d2=  false;\n          const o3=  r2?  b2:  f2;\n          if( r2?  f2:  b2)\n            o3||  Ge(u2._readableStreamController, t5);else\n               {\n            let r3;\n            try {\n              r3=  Se(t5);\n             }catch( t6) {\n              return Qe(u2._readableStreamController, t6), Qe(c2._readableStreamController, t6), void a(Or(e3, t6));\n             }\n            o3||  Ge(u2._readableStreamController, t5), xe(c2._readableStreamController, r3);\n           }\n          l=  false, s?  g2():  d2&&  v();\n         });\n       },_closeSteps: (e4)=>  {\n        l=  false;\n        const t5=  r2?  b2:  f2, o3=  r2?  f2:  b2;\n        t5||  Ye(u2._readableStreamController), o3||  Ye(c2._readableStreamController), e4!==  undefined&&(  t5||  Ge(u2._readableStreamController, e4), !o3&&  c2._readableStreamController._pendingPullIntos.length>  0&&  Ue(c2._readableStreamController, 0)), t5&&  o3||  a(undefined);\n       },_errorSteps: ()=>  {\n        l=  false;\n       }});\n     }\n    function g2() {\n      if( l)\n        return s=  true, c(undefined);\n      l=  true;\n      const e4=  He(o2._readableStreamController);\n      return e4===  null?  p2():  S2(e4._view, false), c(undefined);\n     }\n    function v() {\n      if( l)\n        return d2=  true, c(undefined);\n      l=  true;\n      const e4=  He(n._readableStreamController);\n      return e4===  null?  p2():  S2(e4._view, true), c(undefined);\n     }\n    function w(o3) {\n      if( f2=  true, t3=  o3, b2) {\n        const o4=  ne([t3, r]), n2=  Or(e3, o4);\n        a(n2);\n       }\n      return h2;\n     }\n    function R(o3) {\n      if( b2=  true, r=  o3, f2) {\n        const o4=  ne([t3, r]), n2=  Or(e3, o4);\n        a(n2);\n       }\n      return h2;\n     }\n    function T() {\n     }\n    return o2=  Pr(T, g2, w), n=  Pr(T, v, R), _2(i), [o2, n];\n   }(e2): function(e3, t3) {\n    const r=  H(e3);\n    let o2, n, a, i, l, s=  false, d2=  false, f2=  false, b2=  false;\n    const h2=  u((e4)=>  {\n      l=  e4;\n     });\n    function _2() {\n      if( s)\n        return d2=  true, c(undefined);\n      s=  true;\n      return K(r, { _chunkSteps: (e4)=>  {\n        y(()=>  {\n          d2=  false;\n          const t4=  e4, r2=  e4;\n          f2||  fr(a._readableStreamController, t4), b2||  fr(i._readableStreamController, r2), s=  false, d2&&  _2();\n         });\n       },_closeSteps: ()=>  {\n        s=  false, f2||  dr(a._readableStreamController), b2||  dr(i._readableStreamController), f2&&  b2||  l(undefined);\n       },_errorSteps: ()=>  {\n        s=  false;\n       }}), c(undefined);\n     }\n    function p2(t4) {\n      if( f2=  true, o2=  t4, b2) {\n        const t5=  ne([o2, n]), r2=  Or(e3, t5);\n        l(r2);\n       }\n      return h2;\n     }\n    function S2(t4) {\n      if( b2=  true, n=  t4, f2) {\n        const t5=  ne([o2, n]), r2=  Or(e3, t5);\n        l(r2);\n       }\n      return h2;\n     }\n    function g2() {\n     }\n    return a=  Cr(g2, _2, p2), i=  Cr(g2, _2, S2), m(r._closedPromise, (e4)=>(  br(a._readableStreamController, e4), br(i._readableStreamController, e4), f2&&  b2||  l(undefined), null)), [a, i];\n   }(e2);\n };\nvar Sr=  function(r) {\n  return t(o2=  r)&&  o2.getReader!==  undefined?  function(r2) {\n    let o3;\n    function n() {\n      let e2;\n      try {\n        e2=  r2.read();\n       }catch( e3) {\n        return d(e3);\n       }\n      return _(e2, (e3)=>  {\n        if( !t(e3))\n          throw new TypeError(\"The promise returned by the reader.read() method must fulfill with an object\");\n        if( e3.done)\n          dr(o3._readableStreamController);else\n             {\n          const t2=  e3.value;\n          fr(o3._readableStreamController, t2);\n         }\n       });\n     }\n    function a(e2) {\n      try {\n        return c(r2.cancel(e2));\n       }catch( e3) {\n        return d(e3);\n       }\n     }\n    return o3=  Cr(e, n, a, 0), o3;\n   }(r.getReader()): function(r2) {\n    let o3;\n    const n=  fe(r2, \"async\");\n    function a() {\n      let e2;\n      try {\n        e2=  be(n);\n       }catch( e3) {\n        return d(e3);\n       }\n      return _(c(e2), (e3)=>  {\n        if( !t(e3))\n          throw new TypeError(\"The promise returned by the iterator.next() method must fulfill with an object\");\n        if( e3.done)\n          dr(o3._readableStreamController);else\n             {\n          const t2=  e3.value;\n          fr(o3._readableStreamController, t2);\n         }\n       });\n     }\n    function i(e2) {\n      const r3=  n.iterator;\n      let o4;\n      try {\n        o4=  ue(r3, \"return\");\n       }catch( e3) {\n        return d(e3);\n       }\n      if( o4===  undefined)\n        return c(undefined);\n      return _(g(o4, r3, [e2]), (e3)=>  {\n        if( !t(e3))\n          throw new TypeError(\"The promise returned by the iterator.return() method must fulfill with an object\");\n       });\n     }\n    return o3=  Cr(e, a, i, 0), o3;\n   }(r);\n  var o2;\n };\nvar gr=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  g(e2, t2, [r2]);\n };\nvar vr=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  g(e2, t2, [r2]);\n };\nvar wr=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  S(e2, t2, [r2]);\n };\nvar Rr=  function(e2, t2) {\n  if( (e2=   `${e2}`)!== \"bytes\")\n    throw new TypeError( `${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);\n  return e2;\n };\nvar Tr=  function(e2, t2) {\n  L(e2, t2);\n  const r=  e2==  null?  undefined:  e2.preventAbort, o2=  e2==  null?  undefined:  e2.preventCancel, n=  e2==  null?  undefined:  e2.preventClose, a=  e2==  null?  undefined:  e2.signal;\n  return a!==  undefined&&  function(e3, t3) {\n    if( !function(e4) {\n      if( typeof e4!=  \"object\"||  e4===  null)\n        return false;\n      try {\n        return typeof e4.aborted==  \"boolean\";\n       }catch( e5) {\n        return false;\n       }\n     }(e3))\n      throw new TypeError( `${t3} is not an AbortSignal.`);\n   }(a, `${t2} has member 'signal' that`),{ preventAbort: Boolean(r), preventCancel: Boolean(o2), preventClose: Boolean(n), signal: a};\n };\nvar Cr=  function(e2, t2, r, o2=  1, n=  ()=>  1) {\n  const a=  Object.create(ReadableStream.prototype);\n  qr(a);\n  return _r(a, Object.create(ReadableStreamDefaultController.prototype), e2, t2, r, o2, n), a;\n };\nvar Pr=  function(e2, t2, r) {\n  const o2=  Object.create(ReadableStream.prototype);\n  qr(o2);\n  return Xe(o2, Object.create(ReadableByteStreamController.prototype), e2, t2, r, 0, undefined), o2;\n };\nvar qr=  function(e2) {\n  e2._state=  \"readable\", e2._reader=  undefined, e2._storedError=  undefined, e2._disturbed=  false;\n };\nvar Er=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_readableStreamController\")&&  e2 instanceof ReadableStream;\n };\nvar Wr=  function(e2) {\n  return e2._reader!==  undefined;\n };\nvar Or=  function(t2, r) {\n  if( t2._disturbed=  true, t2._state===  \"closed\")\n    return c(undefined);\n  if( t2._state===  \"errored\")\n    return d(t2._storedError);\n  Br(t2);\n  const o2=  t2._reader;\n  if( o2!==  undefined&&  nt(o2)) {\n    const e2=  o2._readIntoRequests;\n    o2._readIntoRequests=  new v(),e2.forEach((e3)=> {\n      e3._closeSteps(undefined);\n     });\n   }\n  return _(t2._readableStreamController[T](r), e);\n };\nvar Br=  function(e2) {\n  e2._state=  \"closed\";\n  const t2=  e2._reader;\n  if( t2!==  undefined&&(  A(t2), J(t2))) {\n    const e3=  t2._readRequests;\n    t2._readRequests=  new v(),e3.forEach((e4)=> {\n      e4._closeSteps();\n     });\n   }\n };\nvar kr=  function(e2, t2) {\n  e2._state=  \"errored\", e2._storedError=  t2;\n  const r=  e2._reader;\n  r!==  undefined&&(  j(r, t2), J(r)?  Z(r, t2):  it(r, t2));\n };\nvar jr=  function(e2) {\n  return new TypeError( `ReadableStream.prototype.${e2} can only be used on a ReadableStream`);\n };\nvar Ar=  function(e2, t2) {\n  L(e2, t2);\n  const r=  e2==  null?  undefined:  e2.highWaterMark;\n  return M(r, \"highWaterMark\", \"QueuingStrategyInit\"), { highWaterMark: Y(r)};\n };\nvar Dr=  function(e2) {\n  return new TypeError( `ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);\n };\nvar Lr=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_byteLengthQueuingStrategyHighWaterMark\")&&  e2 instanceof ByteLengthQueuingStrategy;\n };\nvar Ir=  function(e2) {\n  return new TypeError( `CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);\n };\nvar $r=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_countQueuingStrategyHighWaterMark\")&&  e2 instanceof CountQueuingStrategy;\n };\nvar Mr=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  g(e2, t2, [r2]);\n };\nvar Yr=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  S(e2, t2, [r2]);\n };\nvar xr=  function(e2, t2, r) {\n  return F(e2, r), (r2, o2)=>  g(e2, t2, [r2, o2]);\n };\nvar Qr=  function(e2, t2, r) {\n  return F(e2, r), (r2)=>  g(e2, t2, [r2]);\n };\nvar Nr=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_transformStreamController\")&&  e2 instanceof TransformStream;\n };\nvar Hr=  function(e2, t2) {\n  br(e2._readable._readableStreamController, t2), Vr(e2, t2);\n };\nvar Vr=  function(e2, t2) {\n  Jr(e2._transformStreamController), Yt(e2._writable._writableStreamController, t2), Ur(e2);\n };\nvar Ur=  function(e2) {\n  e2._backpressure&&  Gr(e2, false);\n };\nvar Gr=  function(e2, t2) {\n  e2._backpressureChangePromise!==  undefined&&  e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise=  u((t3)=>  {\n    e2._backpressureChangePromise_resolve=  t3;\n   }),e2._backpressure=  t2;\n };\nvar Xr=  function(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledTransformStream\")&&  e2 instanceof TransformStreamDefaultController;\n };\nvar Jr=  function(e2) {\n  e2._transformAlgorithm=  undefined, e2._flushAlgorithm=  undefined, e2._cancelAlgorithm=  undefined;\n };\nvar Kr=  function(e2, t2) {\n  const r=  e2._controlledTransformStream, o2=  r._readable._readableStreamController;\n  if( !mr(o2))\n    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n  try {\n    fr(o2, t2);\n   }catch( e3) {\n    throw Vr(r, e3), r._readable._storedError;\n   }\n  const n=  function(e3) {\n    return !ur(e3);\n   }(o2);\n  n!==  r._backpressure&&  Gr(r, true);\n };\nvar Zr=  function(e2, t2) {\n  return _(e2._transformAlgorithm(t2), undefined, (t3)=>  {\n    throw Hr(e2._controlledTransformStream, t3), t3;\n   });\n };\nvar eo=  function(e2) {\n  return new TypeError( `TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);\n };\nvar to=  function(e2) {\n  e2._finishPromise_resolve!==  undefined&&(  e2._finishPromise_resolve(), e2._finishPromise_resolve=  undefined, e2._finishPromise_reject=  undefined);\n };\nvar ro=  function(e2, t2) {\n  e2._finishPromise_reject!==  undefined&&(  p(e2._finishPromise), e2._finishPromise_reject(t2), e2._finishPromise_resolve=  undefined, e2._finishPromise_reject=  undefined);\n };\nvar oo=  function(e2) {\n  return new TypeError( `TransformStream.prototype.${e2} can only be used on a TransformStream`);\n };\nvar r=  e;\nvar n=  Promise;\nvar a=  Promise.resolve.bind(n);\nvar i=  Promise.prototype.then;\nvar l=  Promise.reject.bind(n);\nvar s=  a;\nvar y=  (e2)=>  {\n  if( typeof queueMicrotask==  \"function\")\n    y=  queueMicrotask;else\n       {\n    const e3=  c(undefined);\n    y=  (t2)=>  f(e3, t2);\n   }\n  return y(e2);\n };\n\nclass v {\n             constructor(){\n    this._cursor=  0, this._size=  0, this._front=  { _elements: [], _next: undefined},  this._back=  this._front, this._cursor=  0, this._size=  0;\n   }\n            get length(){\n    return this._size;\n   }\n      push(e2){\n    const t2=  this._back;\n    let r2=  t2;\n    t2._elements.length===  16383&&(  r2=  { _elements: [], _next: undefined}),  t2._elements.push(e2), r2!==  t2&&(  this._back=  r2, t2._next=  r2), ++this._size;\n   }\n       shift(){\n    const e2=  this._front;\n    let t2=  e2;\n    const r2=  this._cursor;\n    let o2=  r2+  1;\n    const n2=  e2._elements, a2=  n2[r2];\n    return o2===  16384&&(  t2=  e2._next, o2=  0), --this._size, this._cursor=  o2, e2!==  t2&&(  this._front=  t2), n2[r2]=  undefined, a2;\n   }\n         forEach(e2){\n    let t2=  this._cursor, r2=  this._front, o2=  r2._elements;\n    for(; !(t2===  o2.length&&  r2._next===  undefined||  t2===  o2.length&&(  r2=  r2._next, o2=  r2._elements, t2=  0, o2.length===  0));)\n      e2(o2[t2]), ++t2;\n   }\n      peek(){\n    const e2=  this._front, t2=  this._cursor;\n    return e2._elements[t2];\n   }}\n\nvar w=  Symbol(\"[[AbortSteps]]\");\nvar R=  Symbol(\"[[ErrorSteps]]\");\nvar T=  Symbol(\"[[CancelSteps]]\");\nvar C=  Symbol(\"[[PullSteps]]\");\nvar P=  Symbol(\"[[ReleaseSteps]]\");\nvar z=  Number.isFinite||  function(e2) {\n  return typeof e2==  \"number\"&&  isFinite(e2);\n };\nvar D=  Math.trunc||  function(e2) {\n  return e2<  0?  Math.ceil(e2):  Math.floor(e2);\n };\n\nclass ReadableStreamDefaultReader {\n             constructor(e2){\n    if( $(e2, 1, \"ReadableStreamDefaultReader\"), N(e2, \"First parameter\"), Wr(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n    q(this, e2), this._readRequests=  new v();\n   }\n            get closed(){\n    return J(this)?  this._closedPromise:  d(ee(\"closed\"));\n   }\n        cancel(e2=undefined){\n    return J(this)?  this._ownerReadableStream===  undefined?  d(O(\"cancel\")):  E(this, e2):  d(ee(\"cancel\"));\n   }\n      read(){\n    if( !J(this))\n      return d(ee(\"read\"));\n    if( this._ownerReadableStream===  undefined)\n      return d(O(\"read from\"));\n    let e2, t2;\n    const r2=  u((r3, o2)=>  {\n      e2=  r3, t2=  o2;\n     });\n    return K(this, { _chunkSteps: (t3)=>  e2({ value: t3, done: false}),  _closeSteps: ()=>  e2({ value: undefined, done: true}),  _errorSteps: (e3)=>  t2(e3)}),  r2;\n   }\n             releaseLock(){\n    if( !J(this))\n      throw ee(\"releaseLock\");\n    this._ownerReadableStream!==  undefined&&  function(e2) {\n      W(e2);\n      const t2=  new TypeError(\"Reader was released\");\n      Z(e2, t2);\n     }(this);\n   }}\n\nvar te;\nvar re;\nvar oe;\nObject.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true},  read: { enumerable: true},  releaseLock: { enumerable: true},  closed: { enumerable: true}}),   o(ReadableStreamDefaultReader.prototype.cancel, \"cancel\"), o(ReadableStreamDefaultReader.prototype.read, \"read\"), o(ReadableStreamDefaultReader.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, { value: \"ReadableStreamDefaultReader\", configurable: true});\nvar ie=  (e2)=>(  ie=  typeof e2.transfer==  \"function\"?  (e3)=>  e3.transfer():  typeof structuredClone==  \"function\"?  (e3)=>  structuredClone(e3, { transfer: [e3]}):   (e3)=>  e3, ie(e2));\nvar le=  (e2)=>(  le=  typeof e2.detached==  \"boolean\"?  (e3)=>  e3.detached:  (e3)=>  e3.byteLength===  0, le(e2));\nvar de=  (oe=  (te=  Symbol.asyncIterator)!==  null&&  te!==  undefined?  te:  (re=  Symbol.for)===  null||  re===  undefined?  undefined:  re.call(Symbol, \"Symbol.asyncIterator\"))!==  null&&  oe!==  undefined?  oe:  \"@@asyncIterator\";\n\nclass he {\n             constructor(e2,t2){\n    this._ongoingPromise=  undefined, this._isFinished=  false, this._reader=  e2, this._preventCancel=  t2;\n   }\n      next(){\n    const e2=  ()=>  this._nextSteps();\n    return this._ongoingPromise=  this._ongoingPromise?  _(this._ongoingPromise, e2, e2):  e2(), this._ongoingPromise;\n   }\n        return(e2){\n    const t2=  ()=>  this._returnSteps(e2);\n    return this._ongoingPromise?  _(this._ongoingPromise, t2, t2):  t2();\n   }\n            _nextSteps(){\n    if( this._isFinished)\n      return Promise.resolve({ value: undefined, done: true});\n    const e2=  this._reader;\n    let t2, r2;\n    const o2=  u((e3, o3)=>  {\n      t2=  e3, r2=  o3;\n     });\n    return K(e2, { _chunkSteps: (e3)=>  {\n      this._ongoingPromise=  undefined, y(()=>  t2({ value: e3, done: false}));\n     },_closeSteps: ()=>  {\n      this._ongoingPromise=  undefined, this._isFinished=  true, W(e2), t2({ value: undefined, done: true});\n     },_errorSteps: (t3)=>  {\n      this._ongoingPromise=  undefined, this._isFinished=  true, W(e2), r2(t3);\n     }}), o2;\n   }\n              _returnSteps(e2){\n    if( this._isFinished)\n      return Promise.resolve({ value: e2, done: true});\n    this._isFinished=  true;\n    const t2=  this._reader;\n    if( !this._preventCancel) {\n      const r2=  E(t2, e2);\n      return W(t2), _(r2, ()=>(  { value: e2, done: true}));\n     }\n    return W(t2), c({ value: e2, done: true});\n   }}\n\nvar me=  { next() {\n  return _e(this)?  this._asyncIteratorImpl.next():  d(pe(\"next\"));\n },return(e2) {\n  return _e(this)?  this._asyncIteratorImpl.return(e2):  d(pe(\"return\"));\n },[de]() {\n  return this;\n }};\nObject.defineProperty(me, de, { enumerable: false});\nvar ye=  Number.isNaN||  function(e2) {\n  return e2!=  e2;\n };\n\nclass ReadableStreamBYOBRequest {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n          get view(){\n    if( !Ce(this))\n      throw Je(\"view\");\n    return this._view;\n   }\n         respond(e2){\n    if( !Ce(this))\n      throw Je(\"respond\");\n    if( $(e2, 1, \"respond\"), e2=  Q(e2, \"First parameter\"), this._associatedReadableByteStreamController===  undefined)\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    if( le(this._view.buffer))\n      throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be used as a response\");\n    Ue(this._associatedReadableByteStreamController, e2);\n   }\n                    respondWithNewView(e2){\n    if( !Ce(this))\n      throw Je(\"respondWithNewView\");\n    if( $(e2, 1, \"respondWithNewView\"), !ArrayBuffer.isView(e2))\n      throw new TypeError(\"You can only respond with array buffer views\");\n    if( this._associatedReadableByteStreamController===  undefined)\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    if( le(e2.buffer))\n      throw new TypeError(\"The given view's buffer has been detached and so cannot be used as a response\");\n    Ge(this._associatedReadableByteStreamController, e2);\n   }}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true},  respondWithNewView: { enumerable: true},  view: { enumerable: true}}),   o(ReadableStreamBYOBRequest.prototype.respond, \"respond\"), o(ReadableStreamBYOBRequest.prototype.respondWithNewView, \"respondWithNewView\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, { value: \"ReadableStreamBYOBRequest\", configurable: true});\n\nclass ReadableByteStreamController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get byobRequest(){\n    if( !Te(this))\n      throw Ke(\"byobRequest\");\n    return He(this);\n   }\n                 get desiredSize(){\n    if( !Te(this))\n      throw Ke(\"desiredSize\");\n    return Ve(this);\n   }\n       close(){\n    if( !Te(this))\n      throw Ke(\"close\");\n    if( this._closeRequested)\n      throw new TypeError(\"The stream has already been closed; do not close it again!\");\n    const e2=  this._controlledReadableByteStream._state;\n    if( e2!==  \"readable\")\n      throw new TypeError( `The stream (in ${e2} state) is not in the readable state and cannot be closed`);\n    Ye(this);\n   }\n         enqueue(e2){\n    if( !Te(this))\n      throw Ke(\"enqueue\");\n    if( $(e2, 1, \"enqueue\"), !ArrayBuffer.isView(e2))\n      throw new TypeError(\"chunk must be an array buffer view\");\n    if( e2.byteLength===  0)\n      throw new TypeError(\"chunk must have non-zero byteLength\");\n    if( e2.buffer.byteLength===  0)\n      throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n    if( this._closeRequested)\n      throw new TypeError(\"stream is closed or draining\");\n    const t2=  this._controlledReadableByteStream._state;\n    if( t2!==  \"readable\")\n      throw new TypeError( `The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);\n    xe(this, e2);\n   }\n       error(e2=undefined){\n    if( !Te(this))\n      throw Ke(\"error\");\n    Qe(this, e2);\n   }\n    [T](e2){\n    qe(this), we(this);\n    const t2=  this._cancelAlgorithm(e2);\n    return Me(this), t2;\n   }\n    [C](e2){\n    const t2=  this._controlledReadableByteStream;\n    if( this._queueTotalSize>  0)\n      return void Ne(this, e2);\n    const r2=  this._autoAllocateChunkSize;\n    if( r2!==  undefined) {\n      let t3;\n      try {\n        t3=  new ArrayBuffer(r2);\n       }catch( t4) {\n        return void e2._errorSteps(t4);\n       }\n      const o2=  { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: \"default\"};\n      this._pendingPullIntos.push(o2);\n     }\n    V(t2, e2), Pe(this);\n   }\n    [P](){\n    if( this._pendingPullIntos.length>  0) {\n      const e2=  this._pendingPullIntos.peek();\n      e2.readerType=  \"none\", this._pendingPullIntos=  new v(),this._pendingPullIntos.push(e2);\n     }\n   }}\n\nObject.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true},  enqueue: { enumerable: true},  error: { enumerable: true},  byobRequest: { enumerable: true},  desiredSize: { enumerable: true}}),   o(ReadableByteStreamController.prototype.close, \"close\"), o(ReadableByteStreamController.prototype.enqueue, \"enqueue\"), o(ReadableByteStreamController.prototype.error, \"error\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, { value: \"ReadableByteStreamController\", configurable: true});\n\nclass ReadableStreamBYOBReader {\n             constructor(e2){\n    if( $(e2, 1, \"ReadableStreamBYOBReader\"), N(e2, \"First parameter\"), Wr(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n    if( !Te(e2._readableStreamController))\n      throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n    q(this, e2), this._readIntoRequests=  new v();\n   }\n            get closed(){\n    return nt(this)?  this._closedPromise:  d(lt(\"closed\"));\n   }\n        cancel(e2=undefined){\n    return nt(this)?  this._ownerReadableStream===  undefined?  d(O(\"cancel\")):  E(this, e2):  d(lt(\"cancel\"));\n   }\n      read(e2,t2={}){\n    if( !nt(this))\n      return d(lt(\"read\"));\n    if( !ArrayBuffer.isView(e2))\n      return d(new TypeError(\"view must be an array buffer view\"));\n    if( e2.byteLength===  0)\n      return d(new TypeError(\"view must have non-zero byteLength\"));\n    if( e2.buffer.byteLength===  0)\n      return d(new TypeError(\"view's buffer must have non-zero byteLength\"));\n    if( le(e2.buffer))\n      return d(new TypeError(\"view's buffer has been detached\"));\n    let r2;\n    try {\n      r2=  function(e3, t3) {\n        var r3;\n        return L(e3, t3), { min: Q((r3=  e3==  null?  undefined:  e3.min)!==  null&&  r3!==  undefined?  r3:  1,  `${t3} has member 'min' that`)};\n       }(t2,\"options\");\n     }catch( e3) {\n      return d(e3);\n     }\n    const o2=  r2.min;\n    if( o2===  0)\n      return d(new TypeError(\"options.min must be greater than 0\"));\n    if( function(e3) {\n      return Re(e3.constructor);\n     }(e2)){\n      if( o2>  e2.byteLength)\n        return d(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n     }else if( o2>  e2.length)\n      return d(new RangeError(\"options.min must be less than or equal to view's length\"));\n    if( this._ownerReadableStream===  undefined)\n      return d(O(\"read from\"));\n    let n2, a2;\n    const i2=  u((e3, t3)=>  {\n      n2=  e3, a2=  t3;\n     });\n    return at(this, e2, o2, { _chunkSteps: (e3)=>  n2({ value: e3, done: false}),  _closeSteps: (e3)=>  n2({ value: e3, done: true}),  _errorSteps: (e3)=>  a2(e3)}),  i2;\n   }\n             releaseLock(){\n    if( !nt(this))\n      throw lt(\"releaseLock\");\n    this._ownerReadableStream!==  undefined&&  function(e2) {\n      W(e2);\n      const t2=  new TypeError(\"Reader was released\");\n      it(e2, t2);\n     }(this);\n   }}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true},  read: { enumerable: true},  releaseLock: { enumerable: true},  closed: { enumerable: true}}),   o(ReadableStreamBYOBReader.prototype.cancel, \"cancel\"), o(ReadableStreamBYOBReader.prototype.read, \"read\"), o(ReadableStreamBYOBReader.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, { value: \"ReadableStreamBYOBReader\", configurable: true});\nvar pt=  typeof AbortController==  \"function\";\n\nclass WritableStream {\n             constructor(e2={},t2={}){\n    e2===  undefined?  e2=  null:  I(e2, \"First parameter\");\n    const r2=  ct(t2, \"Second parameter\"), o2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3==  null?  undefined:  e3.abort, o3=  e3==  null?  undefined:  e3.close, n3=  e3==  null?  undefined:  e3.start, a2=  e3==  null?  undefined:  e3.type, i2=  e3==  null?  undefined:  e3.write;\n      return { abort: r3===  undefined?  undefined:  ft(r3, e3,  `${t3} has member 'abort' that`),close: o3===  undefined?  undefined:  bt(o3, e3,  `${t3} has member 'close' that`),start: n3===  undefined?  undefined:  ht(n3, e3,  `${t3} has member 'start' that`),write: i2===  undefined?  undefined:  mt(i2, e3,  `${t3} has member 'write' that`),type: a2};\n     }(e2,\"First parameter\");\n    St(this);\n    if( o2.type!==  undefined)\n      throw new RangeError(\"Invalid type is specified\");\n    const n2=  ut(r2);\n    (function(e3, t3, r3, o3) {\n      const n3=  Object.create(WritableStreamDefaultController.prototype);\n      let a2, i2, l2, s2;\n      a2=  t3.start!==  undefined?  ()=>  t3.start(n3):  ()=>  {\n       };\n      i2=  t3.write!==  undefined?  (e4)=>  t3.write(e4, n3):  ()=>  c(undefined);\n      l2=  t3.close!==  undefined?  ()=>  t3.close():  ()=>  c(undefined);\n      s2=  t3.abort!==  undefined?  (e4)=>  t3.abort(e4):  ()=>  c(undefined);\n      Ft(e3, n3, a2, i2, l2, s2, r3, o3);\n     })(this,o2, st(r2, 1), n2);\n   }\n            get locked(){\n    if( !gt(this))\n      throw Nt(\"locked\");\n    return vt(this);\n   }\n       abort(e2=undefined){\n    return gt(this)?  vt(this)?  d(new TypeError(\"Cannot abort a stream that already has a writer\")):  wt(this, e2):  d(Nt(\"abort\"));\n   }\n       close(){\n    return gt(this)?  vt(this)?  d(new TypeError(\"Cannot close a stream that already has a writer\")):  qt(this)?  d(new TypeError(\"Cannot close an already-closing stream\")):  Rt(this):  d(Nt(\"close\"));\n   }\n           getWriter(){\n    if( !gt(this))\n      throw Nt(\"getWriter\");\n    return yt(this);\n   }}\n\nObject.defineProperties(WritableStream.prototype, { abort: { enumerable: true},  close: { enumerable: true},  getWriter: { enumerable: true},  locked: { enumerable: true}}),   o(WritableStream.prototype.abort, \"abort\"), o(WritableStream.prototype.close, \"close\"), o(WritableStream.prototype.getWriter, \"getWriter\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, { value: \"WritableStream\", configurable: true});\n\nclass WritableStreamDefaultWriter {\n             constructor(e2){\n    if( $(e2, 1, \"WritableStreamDefaultWriter\"), _t(e2, \"First parameter\"), vt(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n    this._ownerWritableStream=  e2, e2._writer=  this;\n    const t2=  e2._state;\n    if( t2===  \"writable\")\n      !qt(e2)&&  e2._backpressure?  Zt(this):  tr(this), Gt(this);else\n         if( t2===  \"erroring\")\n      er(this, e2._storedError), Gt(this);else\n         if( t2===  \"closed\")\n      tr(this), Gt(r2=  this), Kt(r2);else\n         {\n      const t3=  e2._storedError;\n      er(this, t3), Xt(this, t3);\n     }\n    var r2;\n   }\n            get closed(){\n    return Ot(this)?  this._closedPromise:  d(Vt(\"closed\"));\n   }\n                 get desiredSize(){\n    if( !Ot(this))\n      throw Vt(\"desiredSize\");\n    if( this._ownerWritableStream===  undefined)\n      throw Ut(\"desiredSize\");\n    return function(e2) {\n      const t2=  e2._ownerWritableStream, r2=  t2._state;\n      if( r2===  \"errored\"||  r2===  \"erroring\")\n        return null;\n      if( r2===  \"closed\")\n        return 0;\n      return $t(t2._writableStreamController);\n     }(this);\n   }\n           get ready(){\n    return Ot(this)?  this._readyPromise:  d(Vt(\"ready\"));\n   }\n       abort(e2=undefined){\n    return Ot(this)?  this._ownerWritableStream===  undefined?  d(Ut(\"abort\")):  function(e3, t2) {\n      return wt(e3._ownerWritableStream, t2);\n     }(this,e2):  d(Vt(\"abort\"));\n   }\n       close(){\n    if( !Ot(this))\n      return d(Vt(\"close\"));\n    const e2=  this._ownerWritableStream;\n    return e2===  undefined?  d(Ut(\"close\")):  qt(e2)?  d(new TypeError(\"Cannot close an already-closing stream\")):  Bt(this);\n   }\n             releaseLock(){\n    if( !Ot(this))\n      throw Vt(\"releaseLock\");\n    this._ownerWritableStream!==  undefined&&  At(this);\n   }\n       write(e2=undefined){\n    return Ot(this)?  this._ownerWritableStream===  undefined?  d(Ut(\"write to\")):  zt(this, e2):  d(Vt(\"write\"));\n   }}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true},  close: { enumerable: true},  releaseLock: { enumerable: true},  write: { enumerable: true},  closed: { enumerable: true},  desiredSize: { enumerable: true},  ready: { enumerable: true}}),   o(WritableStreamDefaultWriter.prototype.abort, \"abort\"), o(WritableStreamDefaultWriter.prototype.close, \"close\"), o(WritableStreamDefaultWriter.prototype.releaseLock, \"releaseLock\"), o(WritableStreamDefaultWriter.prototype.write, \"write\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, { value: \"WritableStreamDefaultWriter\", configurable: true});\nvar Dt=  {};\n\nclass WritableStreamDefaultController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get abortReason(){\n    if( !Lt(this))\n      throw Ht(\"abortReason\");\n    return this._abortReason;\n   }\n            get signal(){\n    if( !Lt(this))\n      throw Ht(\"signal\");\n    if( this._abortController===  undefined)\n      throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n    return this._abortController.signal;\n   }\n       error(e2=undefined){\n    if( !Lt(this))\n      throw Ht(\"error\");\n    this._controlledWritableStream._state===  \"writable\"&&  Qt(this, e2);\n   }\n    [w](e2){\n    const t2=  this._abortAlgorithm(e2);\n    return It(this), t2;\n   }\n    [R](){\n    we(this);\n   }}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true},  signal: { enumerable: true},  error: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, { value: \"WritableStreamDefaultController\", configurable: true});\nvar nr=  typeof globalThis!=  \"undefined\"?  globalThis:  typeof self!=  \"undefined\"?  self:  typeof global!=  \"undefined\"?  global:  undefined;\nvar ar=  function() {\n  const e2=  nr==  null?  undefined:  nr.DOMException;\n  return function(e3) {\n    if( typeof e3!=  \"function\"&&  typeof e3!=  \"object\")\n      return false;\n    if( e3.name!==  \"DOMException\")\n      return false;\n    try {\n      return new e3(),true;\n     }catch( e4) {\n      return false;\n     }\n   }(e2)? e2:  undefined;\n }()|| function() {\n  const e2=  function(e3, t2) {\n    this.message=  e3||  \"\", this.name=  t2||  \"Error\", Error.captureStackTrace&&  Error.captureStackTrace(this, this.constructor);\n   };\n  return o(e2, \"DOMException\"), e2.prototype=  Object.create(Error.prototype), Object.defineProperty(e2.prototype, \"constructor\", { value: e2, writable: true, configurable: true}),  e2;\n }();\n\nclass ReadableStreamDefaultController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get desiredSize(){\n    if( !lr(this))\n      throw pr(\"desiredSize\");\n    return hr(this);\n   }\n       close(){\n    if( !lr(this))\n      throw pr(\"close\");\n    if( !mr(this))\n      throw new TypeError(\"The stream is not in a state that permits close\");\n    dr(this);\n   }\n         enqueue(e2=undefined){\n    if( !lr(this))\n      throw pr(\"enqueue\");\n    if( !mr(this))\n      throw new TypeError(\"The stream is not in a state that permits enqueue\");\n    return fr(this, e2);\n   }\n       error(e2=undefined){\n    if( !lr(this))\n      throw pr(\"error\");\n    br(this, e2);\n   }\n    [T](e2){\n    we(this);\n    const t2=  this._cancelAlgorithm(e2);\n    return cr(this), t2;\n   }\n    [C](e2){\n    const t2=  this._controlledReadableStream;\n    if( this._queue.length>  0) {\n      const r2=  ge(this);\n      this._closeRequested&&  this._queue.length===  0?(  cr(this), Br(t2)):  sr(this), e2._chunkSteps(r2);\n     }else\n      V(t2, e2), sr(this);\n   }\n    [P](){\n   }}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true},  enqueue: { enumerable: true},  error: { enumerable: true},  desiredSize: { enumerable: true}}),   o(ReadableStreamDefaultController.prototype.close, \"close\"), o(ReadableStreamDefaultController.prototype.enqueue, \"enqueue\"), o(ReadableStreamDefaultController.prototype.error, \"error\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, { value: \"ReadableStreamDefaultController\", configurable: true});\n\nclass ReadableStream {\n             constructor(e2={},t2={}){\n    e2===  undefined?  e2=  null:  I(e2, \"First parameter\");\n    const r2=  ct(t2, \"Second parameter\"), o2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3, o3=  r3==  null?  undefined:  r3.autoAllocateChunkSize, n2=  r3==  null?  undefined:  r3.cancel, a2=  r3==  null?  undefined:  r3.pull, i2=  r3==  null?  undefined:  r3.start, l2=  r3==  null?  undefined:  r3.type;\n      return { autoAllocateChunkSize: o3===  undefined?  undefined:  Q(o3,  `${t3} has member 'autoAllocateChunkSize' that`),cancel: n2===  undefined?  undefined:  gr(n2, r3,  `${t3} has member 'cancel' that`),pull: a2===  undefined?  undefined:  vr(a2, r3,  `${t3} has member 'pull' that`),start: i2===  undefined?  undefined:  wr(i2, r3,  `${t3} has member 'start' that`),type: l2===  undefined?  undefined:  Rr(l2,  `${t3} has member 'type' that`)};\n     }(e2,\"First parameter\");\n    if( qr(this), o2.type===  \"bytes\") {\n      if( r2.size!==  undefined)\n        throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n      (function(e3, t3, r3) {\n        const o3=  Object.create(ReadableByteStreamController.prototype);\n        let n2, a2, i2;\n        n2=  t3.start!==  undefined?  ()=>  t3.start(o3):  ()=>  {\n         },a2=  t3.pull!==  undefined?  ()=>  t3.pull(o3):  ()=>  c(undefined), i2=  t3.cancel!==  undefined?  (e4)=>  t3.cancel(e4):  ()=>  c(undefined);\n        const l2=  t3.autoAllocateChunkSize;\n        if( l2===  0)\n          throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        Xe(e3, o3, n2, a2, i2, r3, l2);\n       })(this,o2, st(r2, 0));\n     }else {\n      const e3=  ut(r2);\n      (function(e4, t3, r3, o3) {\n        const n2=  Object.create(ReadableStreamDefaultController.prototype);\n        let a2, i2, l2;\n        a2=  t3.start!==  undefined?  ()=>  t3.start(n2):  ()=>  {\n         },i2=  t3.pull!==  undefined?  ()=>  t3.pull(n2):  ()=>  c(undefined), l2=  t3.cancel!==  undefined?  (e5)=>  t3.cancel(e5):  ()=>  c(undefined), _r(e4, n2, a2, i2, l2, r3, o3);\n       })(this,o2, st(r2, 1), e3);\n     }\n   }\n            get locked(){\n    if( !Er(this))\n      throw jr(\"locked\");\n    return Wr(this);\n   }\n        cancel(e2=undefined){\n    return Er(this)?  Wr(this)?  d(new TypeError(\"Cannot cancel a stream that already has a reader\")):  Or(this, e2):  d(jr(\"cancel\"));\n   }\n           getReader(e2=undefined){\n    if( !Er(this))\n      throw jr(\"getReader\");\n    return function(e3, t2) {\n      L(e3, t2);\n      const r2=  e3==  null?  undefined:  e3.mode;\n      return { mode: r2===  undefined?  undefined:  Ze(r2,  `${t2} has member 'mode' that`)};\n     }(e2,\"First parameter\").mode===  undefined?  H(this):  et(this);\n   }\n             pipeThrough(e2,t2={}){\n    if( !Er(this))\n      throw jr(\"pipeThrough\");\n    $(e2, 1, \"pipeThrough\");\n    const r2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3==  null?  undefined:  e3.readable;\n      M(r3, \"readable\", \"ReadableWritablePair\"), N(r3,  `${t3} has member 'readable' that`);\n      const o3=  e3==  null?  undefined:  e3.writable;\n      return M(o3, \"writable\", \"ReadableWritablePair\"), _t(o3,  `${t3} has member 'writable' that`),{ readable: r3, writable: o3};\n     }(e2,\"First parameter\"), o2=  Tr(t2, \"Second parameter\");\n    if( Wr(this))\n      throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n    if( vt(r2.writable))\n      throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n    return p(ir(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;\n   }\n        pipeTo(e2,t2={}){\n    if( !Er(this))\n      return d(jr(\"pipeTo\"));\n    if( e2===  undefined)\n      return d(\"Parameter 1 is required in 'pipeTo'.\");\n    if( !gt(e2))\n      return d(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n    let r2;\n    try {\n      r2=  Tr(t2, \"Second parameter\");\n     }catch( e3) {\n      return d(e3);\n     }\n    return Wr(this)?  d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")):  vt(e2)?  d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")):  ir(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);\n   }\n     tee(){\n    if( !Er(this))\n      throw jr(\"tee\");\n    return ne(yr(this));\n   }\n        values(e2=undefined){\n    if( !Er(this))\n      throw jr(\"values\");\n    return function(e3, t2) {\n      const r2=  H(e3), o2=  new he(r2, t2), n2=  Object.create(me);\n      return n2._asyncIteratorImpl=  o2, n2;\n     }(this,function(e3, t2) {\n      L(e3, t2);\n      const r2=  e3==  null?  undefined:  e3.preventCancel;\n      return { preventCancel: Boolean(r2)};\n     }(e2,\"First parameter\").preventCancel);\n   }\n     [de](e2){\n    return this.values(e2);\n   }\n             static from(e2){\n    return Sr(e2);\n   }}\n\nObject.defineProperties(ReadableStream, { from: { enumerable: true}}),   Object.defineProperties(ReadableStream.prototype, { cancel: { enumerable: true},  getReader: { enumerable: true},  pipeThrough: { enumerable: true},  pipeTo: { enumerable: true},  tee: { enumerable: true},  values: { enumerable: true},  locked: { enumerable: true}}),   o(ReadableStream.from, \"from\"), o(ReadableStream.prototype.cancel, \"cancel\"), o(ReadableStream.prototype.getReader, \"getReader\"), o(ReadableStream.prototype.pipeThrough, \"pipeThrough\"), o(ReadableStream.prototype.pipeTo, \"pipeTo\"), o(ReadableStream.prototype.tee, \"tee\"), o(ReadableStream.prototype.values, \"values\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, { value: \"ReadableStream\", configurable: true}),  Object.defineProperty(ReadableStream.prototype, de, { value: ReadableStream.prototype.values, writable: true, configurable: true});\nvar zr=  (e2)=>  e2.byteLength;\no(zr, \"size\");\n\nclass ByteLengthQueuingStrategy {\n             constructor(e2){\n    $(e2, 1, \"ByteLengthQueuingStrategy\"), e2=  Ar(e2, \"First parameter\"), this._byteLengthQueuingStrategyHighWaterMark=  e2.highWaterMark;\n   }\n                   get highWaterMark(){\n    if( !Lr(this))\n      throw Dr(\"highWaterMark\");\n    return this._byteLengthQueuingStrategyHighWaterMark;\n   }\n          get size(){\n    if( !Lr(this))\n      throw Dr(\"size\");\n    return zr;\n   }}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true},  size: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, { value: \"ByteLengthQueuingStrategy\", configurable: true});\nvar Fr=  ()=>  1;\no(Fr, \"size\");\n\nclass CountQueuingStrategy {\n             constructor(e2){\n    $(e2, 1, \"CountQueuingStrategy\"), e2=  Ar(e2, \"First parameter\"), this._countQueuingStrategyHighWaterMark=  e2.highWaterMark;\n   }\n                   get highWaterMark(){\n    if( !$r(this))\n      throw Ir(\"highWaterMark\");\n    return this._countQueuingStrategyHighWaterMark;\n   }\n          get size(){\n    if( !$r(this))\n      throw Ir(\"size\");\n    return Fr;\n   }}\n\nObject.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true},  size: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, { value: \"CountQueuingStrategy\", configurable: true});\n\nclass TransformStream {\n             constructor(e2={},t2={},r2={}){\n    e2===  undefined&&(  e2=  null);\n    const o2=  ct(t2, \"Second parameter\"), n2=  ct(r2, \"Third parameter\"), a2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3==  null?  undefined:  e3.cancel, o3=  e3==  null?  undefined:  e3.flush, n3=  e3==  null?  undefined:  e3.readableType, a3=  e3==  null?  undefined:  e3.start, i3=  e3==  null?  undefined:  e3.transform, l3=  e3==  null?  undefined:  e3.writableType;\n      return { cancel: r3===  undefined?  undefined:  Qr(r3, e3,  `${t3} has member 'cancel' that`),flush: o3===  undefined?  undefined:  Mr(o3, e3,  `${t3} has member 'flush' that`),readableType: n3, start: a3===  undefined?  undefined:  Yr(a3, e3,  `${t3} has member 'start' that`),transform: i3===  undefined?  undefined:  xr(i3, e3,  `${t3} has member 'transform' that`),writableType: l3};\n     }(e2,\"First parameter\");\n    if( a2.readableType!==  undefined)\n      throw new RangeError(\"Invalid readableType specified\");\n    if( a2.writableType!==  undefined)\n      throw new RangeError(\"Invalid writableType specified\");\n    const i2=  st(n2, 0), l2=  ut(n2), s2=  st(o2, 1), f2=  ut(o2);\n    let h2;\n    (function(e3, t3, r3, o3, n3, a3) {\n      function i3() {\n        return t3;\n       }\n      function l3(t4) {\n        return function(e4, t5) {\n          const r4=  e4._transformStreamController;\n          if( e4._backpressure) {\n            return _(e4._backpressureChangePromise, ()=>  {\n              const o4=  e4._writable;\n              if( o4._state===  \"erroring\")\n                throw o4._storedError;\n              return Zr(r4, t5);\n             });\n           }\n          return Zr(r4, t5);\n         }(e3,t4);\n       }\n      function s3(t4) {\n        return function(e4, t5) {\n          const r4=  e4._transformStreamController;\n          if( r4._finishPromise!==  undefined)\n            return r4._finishPromise;\n          const o4=  e4._readable;\n          r4._finishPromise=  u((e5, t6)=>  {\n            r4._finishPromise_resolve=  e5, r4._finishPromise_reject=  t6;\n           });\n          const n4=  r4._cancelAlgorithm(t5);\n          return Jr(r4), b(n4, ()=>(  o4._state===  \"errored\"?  ro(r4, o4._storedError):(  br(o4._readableStreamController, t5), to(r4)), null), (e5)=>(  br(o4._readableStreamController, e5), ro(r4, e5), null)), r4._finishPromise;\n         }(e3,t4);\n       }\n      function c2() {\n        return function(e4) {\n          const t4=  e4._transformStreamController;\n          if( t4._finishPromise!==  undefined)\n            return t4._finishPromise;\n          const r4=  e4._readable;\n          t4._finishPromise=  u((e5, r5)=>  {\n            t4._finishPromise_resolve=  e5, t4._finishPromise_reject=  r5;\n           });\n          const o4=  t4._flushAlgorithm();\n          return Jr(t4), b(o4, ()=>(  r4._state===  \"errored\"?  ro(t4, r4._storedError):(  dr(r4._readableStreamController), to(t4)), null), (e5)=>(  br(r4._readableStreamController, e5), ro(t4, e5), null)), t4._finishPromise;\n         }(e3);\n       }\n      function d2() {\n        return function(e4) {\n          return Gr(e4, false), e4._backpressureChangePromise;\n         }(e3);\n       }\n      function f3(t4) {\n        return function(e4, t5) {\n          const r4=  e4._transformStreamController;\n          if( r4._finishPromise!==  undefined)\n            return r4._finishPromise;\n          const o4=  e4._writable;\n          r4._finishPromise=  u((e5, t6)=>  {\n            r4._finishPromise_resolve=  e5, r4._finishPromise_reject=  t6;\n           });\n          const n4=  r4._cancelAlgorithm(t5);\n          return Jr(r4), b(n4, ()=>(  o4._state===  \"errored\"?  ro(r4, o4._storedError):(  Yt(o4._writableStreamController, t5), Ur(e4), to(r4)), null), (t6)=>(  Yt(o4._writableStreamController, t6), Ur(e4), ro(r4, t6), null)), r4._finishPromise;\n         }(e3,t4);\n       }\n      e3._writable=  function(e4, t4, r4, o4, n4=  1, a4=  ()=>  1) {\n        const i4=  Object.create(WritableStream.prototype);\n        return St(i4), Ft(i4, Object.create(WritableStreamDefaultController.prototype), e4, t4, r4, o4, n4, a4), i4;\n       }(i3,l3, c2, s3, r3, o3), e3._readable=  Cr(i3, d2, f3, n3, a3), e3._backpressure=  undefined, e3._backpressureChangePromise=  undefined, e3._backpressureChangePromise_resolve=  undefined, Gr(e3, true), e3._transformStreamController=  undefined;\n     })(this,u((e3)=>  {\n      h2=  e3;\n     }),s2, f2, i2, l2), function(e3, t3) {\n      const r3=  Object.create(TransformStreamDefaultController.prototype);\n      let o3, n3, a3;\n      o3=  t3.transform!==  undefined?  (e4)=>  t3.transform(e4, r3):  (e4)=>  {\n        try {\n          return Kr(r3, e4), c(undefined);\n         }catch( e5) {\n          return d(e5);\n         }\n       };\n      n3=  t3.flush!==  undefined?  ()=>  t3.flush(r3):  ()=>  c(undefined);\n      a3=  t3.cancel!==  undefined?  (e4)=>  t3.cancel(e4):  ()=>  c(undefined);\n      (function(e4, t4, r4, o4, n4) {\n        t4._controlledTransformStream=  e4, e4._transformStreamController=  t4, t4._transformAlgorithm=  r4, t4._flushAlgorithm=  o4, t4._cancelAlgorithm=  n4, t4._finishPromise=  undefined, t4._finishPromise_resolve=  undefined, t4._finishPromise_reject=  undefined;\n       })(e3,r3, o3, n3, a3);\n     }(this,a2), a2.start!==  undefined?  h2(a2.start(this._transformStreamController)):  h2(undefined);\n   }\n              get readable(){\n    if( !Nr(this))\n      throw oo(\"readable\");\n    return this._readable;\n   }\n              get writable(){\n    if( !Nr(this))\n      throw oo(\"writable\");\n    return this._writable;\n   }}\n\nObject.defineProperties(TransformStream.prototype, { readable: { enumerable: true},  writable: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, { value: \"TransformStream\", configurable: true});\n\nclass TransformStreamDefaultController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get desiredSize(){\n    if( !Xr(this))\n      throw eo(\"desiredSize\");\n    return hr(this._controlledTransformStream._readable._readableStreamController);\n   }\n         enqueue(e2=undefined){\n    if( !Xr(this))\n      throw eo(\"enqueue\");\n    Kr(this, e2);\n   }\n       error(e2=undefined){\n    if( !Xr(this))\n      throw eo(\"error\");\n    var t2;\n    t2=  e2, Hr(this._controlledTransformStream, t2);\n   }\n           terminate(){\n    if( !Xr(this))\n      throw eo(\"terminate\");\n    (function(e2) {\n      const t2=  e2._controlledTransformStream;\n      dr(t2._readable._readableStreamController);\n      const r2=  new TypeError(\"TransformStream terminated\");\n      Vr(t2, r2);\n     })(this);\n   }}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true},  error: { enumerable: true},  terminate: { enumerable: true},  desiredSize: { enumerable: true}}),   o(TransformStreamDefaultController.prototype.enqueue, \"enqueue\"), o(TransformStreamDefaultController.prototype.error, \"error\"), o(TransformStreamDefaultController.prototype.terminate, \"terminate\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, { value: \"TransformStreamDefaultController\", configurable: true});\n\n// ../../node_modules/@opensouls/core/dist/minimal.mjs\nvar $c‍_forkStream=function(originalStream,count= 2) {\n  const streams=  Array.from({ length: count},  ()=>  {\n    let controller=  { current: null};\n    const stream=  new ReadableStream({\n      start(c2) {\n        controller.current=  c2;\n       },\n      cancel() {\n        console.log(\"Stream was cancelled.\");\n       }});\n\n    return {\n      stream,\n      controller};\n\n   });\n  const processStream=  async()=>   {\n    try {\n      for await( const chunk of originalStream) {\n        streams.forEach(({ stream, controller})=>   {\n          if( controller.current) {\n            controller.current.enqueue(chunk);\n           }\n         });\n       }\n      streams.forEach(({ stream, controller})=>   {\n        if( controller.current) {\n          controller.current.close();\n         }\n       });\n     }catch( err) {\n      console.error(\"Error processing stream:\", err);\n      streams.forEach(({ stream, controller})=>   {\n        if( controller.current) {\n          controller.current.error(err);\n         }\n       });\n     }\n   };\n  processStream();\n  return streams.map(({ stream})=>   stream);\n };forkStream=$c‍_forkStream;\n\nvar $c‍_createCognitiveStep=(transformationOptionsGenerator)=>{\n  return async( workingMemory, singleArg, opts=  {})=>  {\n    const transformOpts=  transformationOptionsGenerator(singleArg);\n    return workingMemory.transform(transformOpts, opts);\n   };\n };createCognitiveStep=$c‍_createCognitiveStep;\nvar $c‍_indentNicely=codeBlock;indentNicely=$c‍_indentNicely;\nvar $c‍_stripEntityAndVerb=(soulName,_verb,response)=>  {\n  let strippedResponse=  response.replace(new RegExp( `${soulName}.*?:`,\"i\"), \"\").trim();\n  strippedResponse=  strippedResponse.replace(/^[\"']|[\"']$/g, \"\").trim();\n  return strippedResponse;\n };stripEntityAndVerb=$c‍_stripEntityAndVerb;\nvar $c‍_stripEntityAndVerbFromStream=async({soulName},  stream)=>  {\n  const prefix=  new RegExp( `^${soulName}.*?:\\\\s*[\"']*`,\"i\");\n  const suffix=  /[\"']$/;\n  let isStreaming=  !prefix;\n  let prefixMatched=  !prefix;\n  let buffer=  \"\";\n  const isStreamingBuffer=  [];\n  const processedStream=  async function*()  {\n    for await( const chunk of stream) {\n      if( isStreaming) {\n        if( !suffix) {\n          yield chunk;\n          continue;\n         }\n        isStreamingBuffer.push(chunk);\n        if( isStreamingBuffer.length>  2) {\n          yield isStreamingBuffer.shift();\n         }\n        continue;\n       }\n      buffer+=  chunk;\n      if( prefix&&  prefix.test(buffer)) {\n        if( prefixMatched) {\n          isStreaming=  true;\n          buffer=  buffer.replace(prefix, \"\");\n          yield buffer;\n          buffer=  \"\";\n          continue;\n         }\n        prefixMatched=  true;\n       }\n     }\n    buffer=  [buffer, ...isStreamingBuffer].join(\"\");\n    if( !isStreaming&&  prefix) {\n      buffer=  buffer.replace(prefix, \"\");\n     }\n    if( buffer.length>  0) {\n      if( suffix) {\n        buffer=  buffer.replace(suffix, \"\");\n        yield buffer;\n        return;\n       }\n      yield buffer;\n     }\n   }();\n  return processedStream;\n };stripEntityAndVerbFromStream=$c‍_stripEntityAndVerbFromStream;\nvar $c‍_ChatMessageRoleEnum=((ChatMessageRoleEnum2)=>{\n  ChatMessageRoleEnum2[\"System\"]=  \"system\";\n  ChatMessageRoleEnum2[\"User\"]=  \"user\";\n  ChatMessageRoleEnum2[\"Assistant\"]=  \"assistant\";\n  ChatMessageRoleEnum2[\"Function\"]=  \"function\";\n  return ChatMessageRoleEnum2;\n })(ChatMessageRoleEnum|| {});\n// soul-engine-bundle/index.ts\nChatMessageRoleEnum=$c‍_ChatMessageRoleEnum;var getHooks=()=>{\n  if( !globalThis.soul) {\n    throw new Error(\"missing soul, are you running this on the soul engine?\");\n   }\n  return globalThis.soul.__hooks;\n };\nvar $c‍_useActions=()=>{\n  return getHooks().useActions();\n };useActions=$c‍_useActions;\nvar $c‍_useProcessManager=()=>{\n  return getHooks().useProcessManager();\n };useProcessManager=$c‍_useProcessManager;\nvar $c‍_usePerceptions=()=>{\n  return getHooks().usePerceptions();\n };usePerceptions=$c‍_usePerceptions;\nvar $c‍_useProcessMemory=(initialValue)=>{\n  return getHooks().useProcessMemory(initialValue);\n };useProcessMemory=$c‍_useProcessMemory;\nvar $c‍_useSoulStore=()=>{\n  return getHooks().useSoulStore();\n };useSoulStore=$c‍_useSoulStore;\nvar $c‍_useBlueprintStore=(bucketName)=>{\n  return getHooks().useBlueprintStore(bucketName);\n };useBlueprintStore=$c‍_useBlueprintStore;\nvar $c‍_useOrganizationStore=(bucketName)=>{\n  return getHooks().useOrganizationStore(bucketName);\n };useOrganizationStore=$c‍_useOrganizationStore;\nvar $c‍_useSoulMemory=(name,initialValue)=> {\n  return getHooks().useSoulMemory(name, initialValue);\n };useSoulMemory=$c‍_useSoulMemory;\nvar $c‍_useRag=(bucketName)=>{\n  return getHooks().useRag(bucketName);\n };useRag=$c‍_useRag;\nvar $c‍_useTool=(toolName)=>{\n  return getHooks().useTool(toolName);\n };useTool=$c‍_useTool;\nvar $c‍_useSharedContext=(contextName)=>{\n  return getHooks().useSharedContext(contextName);\n };\n\n// soul-engine-bundle/opensouls-bundle.ts\nuseSharedContext=$c‍_useSharedContext;class FakeWorkingMemory{}\n\nvar $c‍_WorkingMemory=new Proxy(FakeWorkingMemory,{\n  construct(_target, args) {\n    return new globalThis.___WorkingMemory(args[0]);\n   }});WorkingMemory=$c‍_WorkingMemory;\n})()\n//# sourceURL=main\n","__liveExportMap__":{"z":["z2",false],"forkStream":["forkStream",true],"createCognitiveStep":["createCognitiveStep",true],"indentNicely":["indentNicely",true],"stripEntityAndVerb":["stripEntityAndVerb",true],"stripEntityAndVerbFromStream":["stripEntityAndVerbFromStream",true],"ChatMessageRoleEnum":["ChatMessageRoleEnum",true],"useActions":["useActions",true],"useProcessManager":["useProcessManager",true],"usePerceptions":["usePerceptions",true],"useProcessMemory":["useProcessMemory",true],"useSoulStore":["useSoulStore",true],"useBlueprintStore":["useBlueprintStore",true],"useOrganizationStore":["useOrganizationStore",true],"useSoulMemory":["useSoulMemory",true],"useRag":["useRag",true],"useTool":["useTool",true],"useSharedContext":["useSharedContext",true],"WorkingMemory":["WorkingMemory",true]},"__reexportMap__":{},"__fixedExportMap__":{},"__needsImportMeta__":false}